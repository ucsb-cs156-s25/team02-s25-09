import {
  B,
  B2,
  D,
  I,
  K,
  L,
  N,
  P,
  Q,
  SE,
  TE,
  U,
  V,
  W,
  X,
  Y,
  a,
  b,
  e,
  f,
  j,
  k,
  m,
  m2,
  n,
  n2,
  p,
  q,
  r,
  s,
  t,
  u,
  w,
  x,
  z
} from "./chunk-YULXVUVA.js";
import {
  __require
} from "./chunk-MTI3AIJG.js";

// node_modules/@storybook/core/dist/preview-errors.js
var oe = Object.defineProperty;
var t2 = (u2, n3) => oe(u2, "name", { value: n3, configurable: true });
function r2(u2) {
  for (var n3 = [], e2 = 1; e2 < arguments.length; e2++)
    n3[e2 - 1] = arguments[e2];
  var a2 = Array.from(typeof u2 == "string" ? [u2] : u2);
  a2[a2.length - 1] = a2[a2.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var g = a2.reduce(function(i, m3) {
    var y2 = m3.match(/\n([\t ]+|(?!\s).)/g);
    return y2 ? i.concat(y2.map(function(E2) {
      var l, d;
      return (d = (l = E2.match(/[\t ]/g)) === null || l === void 0 ? void 0 : l.length) !== null && d !== void 0 ? d : 0;
    })) : i;
  }, []);
  if (g.length) {
    var h = new RegExp(`
[	 ]{` + Math.min.apply(Math, g) + "}", "g");
    a2 = a2.map(function(i) {
      return i.replace(h, `
`);
    });
  }
  a2[0] = a2[0].replace(/^\r?\n/, "");
  var c = a2[0];
  return n3.forEach(function(i, m3) {
    var y2 = c.match(/(?:^|\n)( *)$/), E2 = y2 ? y2[1] : "", l = i;
    typeof i == "string" && i.includes(`
`) && (l = String(i).split(`
`).map(function(d, te3) {
      return te3 === 0 ? d : "" + E2 + d;
    }).join(`
`)), c += l + a2[m3 + 1];
  }), c;
}
t2(r2, "dedent");
function C({
  code: u2,
  category: n3
}) {
  let e2 = String(u2).padStart(4, "0");
  return `SB_${n3}_${e2}`;
}
t2(C, "parseErrorCode");
var p2 = class p3 extends Error {
  constructor(e2) {
    super(p3.getFullMessage(e2));
    this.data = {};
    this.fromStorybook = true;
    this.category = e2.category, this.documentation = e2.documentation ?? false, this.code = e2.code;
  }
  get fullErrorCode() {
    return C({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let e2 = this.constructor.name;
    return `${this.fullErrorCode} (${e2})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: e2,
    code: a2,
    category: g,
    message: h
  }) {
    let c;
    return e2 === true ? c = `https://storybook.js.org/error/${C({ code: a2, category: g })}` : typeof e2 == "string" ? c = e2 : Array.isArray(e2) && (c = `
${e2.map((i) => `	- ${i}`).join(`
`)}`), `${h}${c != null ? `

More info: ${c}
` : ""}`;
  }
};
t2(p2, "StorybookError");
var o = p2;
var se = ((s4) => (s4.BLOCKS = "BLOCKS", s4.DOCS_TOOLS = "DOCS-TOOLS", s4.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", s4.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", s4.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", s4.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", s4.PREVIEW_API = "PREVIEW_API", s4.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", s4.PREVIEW_ROUTER = "PREVIEW_ROUTER", s4.PREVIEW_THEMING = "PREVIEW_THEMING", s4.RENDERER_HTML = "RENDERER_HTML", s4.RENDERER_PREACT = "RENDERER_PREACT", s4.RENDERER_REACT = "RENDERER_REACT", s4.RENDERER_SERVER = "RENDERER_SERVER", s4.RENDERER_SVELTE = "RENDERER_SVELTE", s4.RENDERER_VUE = "RENDERER_VUE", s4.RENDERER_VUE3 = "RENDERER_VUE3", s4.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", s4.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", s4.ADDON_VITEST = "ADDON_VITEST", s4))(se || {});
var f2 = class f3 extends o {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 1,
      message: r2`
        Couldn't find story matching id '${e2.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${e2.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    });
    this.data = e2;
  }
};
t2(f2, "MissingStoryAfterHmrError");
var D2 = f2;
var R = class R2 extends o {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: r2`
        We detected that you use an implicit action arg while ${e2.phase} of your story.  
        ${e2.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from '@storybook/test';
          ... 
          args: {
           ${e2.name}: fn()
          }`
    });
    this.data = e2;
  }
};
t2(R, "ImplicitActionsDuringRendering");
var b2 = class b3 extends o {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 3,
      message: r2`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
t2(b2, "CalledExtractOnStoreError");
var L2 = b2;
var I2 = class I3 extends o {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 4,
      message: r2`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
t2(I2, "MissingRenderToCanvasError");
var G = I2;
var P2 = class P3 extends o {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 5,
      message: r2`
        Called \`Preview.${e2.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${e2.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    });
    this.data = e2;
  }
};
t2(P2, "CalledPreviewMethodBeforeInitializationError");
var Y2 = P2;
var x2 = class x3 extends o {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 6,
      message: r2`
        Error fetching \`/index.json\`:
        
        ${e2.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    });
    this.data = e2;
  }
};
t2(x2, "StoryIndexFetchError");
var M = x2;
var T = class T2 extends o {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 7,
      message: r2`
        Tried to render docs entry ${e2.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    });
    this.data = e2;
  }
};
t2(T, "MdxFileWithNoCsfReferencesError");
var H = T;
var w2 = class w3 extends o {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 8,
      message: r2`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
};
t2(w2, "EmptyIndexError");
var F = w2;
var k2 = class k3 extends o {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 9,
      message: r2`
        Couldn't find story matching '${e2.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    });
    this.data = e2;
  }
};
t2(k2, "NoStoryMatchError");
var K2 = k2;
var S = class S2 extends o {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 10,
      message: r2`
        Couldn't find story matching id '${e2.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    });
    this.data = e2;
  }
};
t2(S, "MissingStoryFromCsfFileError");
var X2 = S;
var v = class v2 extends o {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 11,
      message: r2`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
t2(v, "StoryStoreAccessedBeforeInitializationError");
var U2 = v;
var _ = class _2 extends o {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 12,
      message: r2`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${e2.playFunction}`
    });
    this.data = e2;
  }
};
t2(_, "MountMustBeDestructuredError");
var J = _;
var V2 = class V3 extends o {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 14,
      message: r2`
        No render function available for storyId '${e2.id}'
      `
    });
    this.data = e2;
  }
};
t2(V2, "NoRenderFunctionError");
var q2 = V2;
var N2 = class N3 extends o {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 15,
      message: r2`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          // 👈 mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
t2(N2, "NoStoryMountedError");
var z2 = N2;
var A = class A2 extends o {
  constructor() {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: r2`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
};
t2(A, "NextJsSharpError");
var W2 = class W3 extends o {
  constructor(e2) {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 2,
      message: r2`
        Tried to access router mocks from "${e2.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    });
    this.data = e2;
  }
};
t2(W2, "NextjsRouterMocksNotAvailable");
var $ = class $2 extends o {
  constructor(e2) {
    super({
      category: "DOCS-TOOLS",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: r2`
        There was a failure when generating detailed ArgTypes in ${e2.language} for:
        ${JSON.stringify(e2.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    });
    this.data = e2;
  }
};
t2($, "UnknownArgTypesError");
var Z = $;
var O = class O2 extends o {
  constructor(e2) {
    super({
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: r2`
        Encountered an unsupported value "${e2.value}" when setting the viewport ${e2.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    });
    this.data = e2;
  }
};
t2(O, "UnsupportedViewportDimensionError");
var ee = O;

// node_modules/@storybook/core/dist/csf/index.js
var b4 = Object.create;
var f4 = Object.defineProperty;
var v3 = Object.getOwnPropertyDescriptor;
var P4 = Object.getOwnPropertyNames;
var O3 = Object.getPrototypeOf;
var _3 = Object.prototype.hasOwnProperty;
var s2 = (e2, r3) => f4(e2, "name", { value: r3, configurable: true });
var $3 = (e2, r3) => () => (r3 || e2((r3 = { exports: {} }).exports, r3), r3.exports);
var j2 = (e2, r3, t3, n3) => {
  if (r3 && typeof r3 == "object" || typeof r3 == "function")
    for (let a2 of P4(r3))
      !_3.call(e2, a2) && a2 !== t3 && f4(e2, a2, { get: () => r3[a2], enumerable: !(n3 = v3(r3, a2)) || n3.enumerable });
  return e2;
};
var C2 = (e2, r3, t3) => (t3 = e2 != null ? b4(O3(e2)) : {}, j2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  r3 || !e2 || !e2.__esModule ? f4(t3, "default", { value: e2, enumerable: true }) : t3,
  e2
));
var T3 = $3((g) => {
  Object.defineProperty(g, "__esModule", { value: true }), g.isEqual = /* @__PURE__ */ function() {
    var e2 = Object.prototype.toString, r3 = Object.getPrototypeOf, t3 = Object.getOwnPropertySymbols ? function(n3) {
      return Object.keys(n3).concat(Object.getOwnPropertySymbols(n3));
    } : Object.keys;
    return function(n3, a2) {
      return s2(function d(o2, i, p4) {
        var c, u2, l, m3 = e2.call(o2), h = e2.call(i);
        if (o2 === i) return true;
        if (o2 == null || i == null) return false;
        if (p4.indexOf(o2) > -1 && p4.indexOf(i) > -1) return true;
        if (p4.push(o2, i), m3 != h || (c = t3(o2), u2 = t3(i), c.length != u2.length || c.some(function(A3) {
          return !d(o2[A3], i[A3], p4);
        }))) return false;
        switch (m3.slice(8, -1)) {
          case "Symbol":
            return o2.valueOf() == i.valueOf();
          case "Date":
          case "Number":
            return +o2 == +i || +o2 != +o2 && +i != +i;
          case "RegExp":
          case "Function":
          case "String":
          case "Boolean":
            return "" + o2 == "" + i;
          case "Set":
          case "Map":
            c = o2.entries(), u2 = i.entries();
            do
              if (!d((l = c.next()).value, u2.next().value, p4)) return false;
            while (!l.done);
            return true;
          case "ArrayBuffer":
            o2 = new Uint8Array(o2), i = new Uint8Array(i);
          case "DataView":
            o2 = new Uint8Array(o2.buffer), i = new Uint8Array(i.buffer);
          case "Float32Array":
          case "Float64Array":
          case "Int8Array":
          case "Int16Array":
          case "Int32Array":
          case "Uint8Array":
          case "Uint16Array":
          case "Uint32Array":
          case "Uint8ClampedArray":
          case "Arguments":
          case "Array":
            if (o2.length != i.length) return false;
            for (l = 0; l < o2.length; l++) if ((l in o2 || l in i) && (l in o2 != l in i || !d(o2[l], i[l], p4))) return false;
            return true;
          case "Object":
            return d(r3(o2), r3(i), p4);
          default:
            return false;
        }
      }, "n")(n3, a2, []);
    };
  }();
});
function R3(e2) {
  return e2.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (r3, t3, n3, a2) => `${t3} ${n3}${a2}`).replace(
    /([a-z])([A-Z])/g,
    (r3, t3, n3) => `${t3} ${n3}`
  ).replace(/([a-z])([0-9])/gi, (r3, t3, n3) => `${t3} ${n3}`).replace(/([0-9])([a-z])/gi, (r3, t3, n3) => `${t3} ${n3}`).replace(/(\s|^)(\w)/g, (r3, t3, n3) => `${t3}${n3.toUpperCase()}`).replace(/ +/g, " ").trim();
}
s2(R3, "toStartCaseStr");
var y = C2(T3(), 1);
var x4 = s2((e2) => e2.map((r3) => typeof r3 < "u").filter(Boolean).length, "count");
var E = s2((e2, r3) => {
  let { exists: t3, eq: n3, neq: a2, truthy: d } = e2;
  if (x4([t3, n3, a2, d]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists: t3, eq: n3, neq: a2 })}`);
  if (typeof n3 < "u")
    return (0, y.isEqual)(r3, n3);
  if (typeof a2 < "u")
    return !(0, y.isEqual)(r3, a2);
  if (typeof t3 < "u") {
    let i = typeof r3 < "u";
    return t3 ? i : !i;
  }
  return (typeof d > "u" ? true : d) ? !!r3 : !r3;
}, "testValue");
var z3 = s2((e2, r3, t3) => {
  if (!e2.if)
    return true;
  let { arg: n3, global: a2 } = e2.if;
  if (x4([n3, a2]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg: n3, global: a2 })}`);
  let d = n3 ? r3[n3] : t3[a2];
  return E(e2.if, d);
}, "includeConditionalArg");
function L3(e2) {
  let r3, t3 = {
    _tag: "Preview",
    input: e2,
    get composed() {
      if (r3)
        return r3;
      let { addons: n3, ...a2 } = e2;
      return r3 = be(Ee([...n3 ?? [], a2])), r3;
    },
    meta(n3) {
      return I4(n3, this);
    }
  };
  return globalThis.globalProjectAnnotations = t3.composed, t3;
}
s2(L3, "__definePreview");
function W4(e2) {
  return e2 != null && typeof e2 == "object" && "_tag" in e2 && (e2 == null ? void 0 : e2._tag) === "Preview";
}
s2(W4, "isPreview");
function H2(e2) {
  return e2 != null && typeof e2 == "object" && "_tag" in e2 && (e2 == null ? void 0 : e2._tag) === "Meta";
}
s2(H2, "isMeta");
function I4(e2, r3) {
  return {
    _tag: "Meta",
    input: e2,
    preview: r3,
    get composed() {
      throw new Error("Not implemented");
    },
    story(t3) {
      return U3(t3, this);
    }
  };
}
s2(I4, "defineMeta");
function U3(e2, r3) {
  return {
    _tag: "Story",
    input: e2,
    meta: r3,
    get composed() {
      throw new Error("Not implemented");
    }
  };
}
s2(U3, "defineStory");
function K3(e2) {
  return e2 != null && typeof e2 == "object" && "_tag" in e2 && (e2 == null ? void 0 : e2._tag) === "Story";
}
s2(K3, "isStory");
var D3 = s2((e2) => e2.toLowerCase().replace(/[ ’–—―′¿'`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(
  /-+/g,
  "-"
).replace(/^-+/, "").replace(/-+$/, ""), "sanitize");
var w4 = s2((e2, r3) => {
  let t3 = D3(e2);
  if (t3 === "")
    throw new Error(`Invalid ${r3} '${e2}', must include alphanumeric characters`);
  return t3;
}, "sanitizeSafe");
var ee2 = s2((e2, r3) => `${w4(e2, "kind")}${r3 ? `--${w4(r3, "name")}` : ""}`, "toId");
var re = s2((e2) => R3(
  e2
), "storyNameFromExport");
function S3(e2, r3) {
  return Array.isArray(r3) ? r3.includes(e2) : e2.match(r3);
}
s2(S3, "matches");
function te(e2, { includeStories: r3, excludeStories: t3 }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    e2 !== "__esModule" && (!r3 || S3(e2, r3)) && (!t3 || !S3(e2, t3))
  );
}
s2(te, "isExportStory");
var ne = s2((e2, { rootSeparator: r3, groupSeparator: t3 }) => {
  let [n3, a2] = e2.split(r3, 2), d = (a2 || e2).split(t3).filter((o2) => !!o2);
  return {
    root: a2 ? n3 : null,
    groups: d
  };
}, "parseKind");
var oe2 = s2((...e2) => {
  let r3 = e2.reduce((t3, n3) => (n3.startsWith("!") ? t3.delete(n3.slice(1)) : t3.add(n3), t3), /* @__PURE__ */ new Set());
  return Array.from(r3);
}, "combineTags");

// node_modules/@storybook/core/dist/preview-api/index.js
var zn = Object.create;
var br = Object.defineProperty;
var Vn = Object.getOwnPropertyDescriptor;
var Hn = Object.getOwnPropertyNames;
var Wn = Object.getPrototypeOf;
var $n = Object.prototype.hasOwnProperty;
var s3 = (r3, e2) => br(r3, "name", { value: e2, configurable: true });
var Fe = ((r3) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(r3, {
  get: (e2, t3) => (typeof __require < "u" ? __require : e2)[t3]
}) : r3)(function(r3) {
  if (typeof __require < "u") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + r3 + '" is not supported');
});
var k4 = (r3, e2) => () => (e2 || r3((e2 = { exports: {} }).exports, e2), e2.exports);
var Yn = (r3, e2, t3, o2) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let n3 of Hn(e2))
      !$n.call(r3, n3) && n3 !== t3 && br(r3, n3, { get: () => e2[n3], enumerable: !(o2 = Vn(e2, n3)) || o2.enumerable });
  return r3;
};
var he = (r3, e2, t3) => (t3 = r3 != null ? zn(Wn(r3)) : {}, Yn(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e2 || !r3 || !r3.__esModule ? br(t3, "default", { value: r3, enumerable: true }) : t3,
  r3
));
var _r = k4((io, Mr) => {
  (function(r3) {
    if (typeof io == "object" && typeof Mr < "u")
      Mr.exports = r3();
    else if (typeof define == "function" && define.amd)
      define([], r3);
    else {
      var e2;
      typeof window < "u" ? e2 = window : typeof global < "u" ? e2 = global : typeof self < "u" ? e2 = self : e2 = this, e2.memoizerific = r3();
    }
  })(function() {
    var r3, e2, t3;
    return s3(function o2(n3, i, a2) {
      function l(p4, u2) {
        if (!i[p4]) {
          if (!n3[p4]) {
            var y2 = typeof Fe == "function" && Fe;
            if (!u2 && y2) return y2(p4, true);
            if (c) return c(p4, true);
            var m3 = new Error("Cannot find module '" + p4 + "'");
            throw m3.code = "MODULE_NOT_FOUND", m3;
          }
          var g = i[p4] = { exports: {} };
          n3[p4][0].call(g.exports, function(S4) {
            var h = n3[p4][1][S4];
            return l(h || S4);
          }, g, g.exports, o2, n3, i, a2);
        }
        return i[p4].exports;
      }
      s3(l, "s");
      for (var c = typeof Fe == "function" && Fe, d = 0; d < a2.length; d++) l(a2[d]);
      return l;
    }, "e")({ 1: [function(o2, n3, i) {
      n3.exports = function(a2) {
        if (typeof Map != "function" || a2) {
          var l = o2("./similar");
          return new l();
        } else
          return /* @__PURE__ */ new Map();
      };
    }, { "./similar": 2 }], 2: [function(o2, n3, i) {
      function a2() {
        return this.list = [], this.lastItem = void 0, this.size = 0, this;
      }
      s3(a2, "Similar"), a2.prototype.get = function(l) {
        var c;
        if (this.lastItem && this.isEqual(this.lastItem.key, l))
          return this.lastItem.val;
        if (c = this.indexOf(l), c >= 0)
          return this.lastItem = this.list[c], this.list[c].val;
      }, a2.prototype.set = function(l, c) {
        var d;
        return this.lastItem && this.isEqual(this.lastItem.key, l) ? (this.lastItem.val = c, this) : (d = this.indexOf(l), d >= 0 ? (this.lastItem = this.list[d], this.list[d].val = c, this) : (this.lastItem = { key: l, val: c }, this.list.push(this.lastItem), this.size++, this));
      }, a2.prototype.delete = function(l) {
        var c;
        if (this.lastItem && this.isEqual(this.lastItem.key, l) && (this.lastItem = void 0), c = this.indexOf(l), c >= 0)
          return this.size--, this.list.splice(c, 1)[0];
      }, a2.prototype.has = function(l) {
        var c;
        return this.lastItem && this.isEqual(this.lastItem.key, l) ? true : (c = this.indexOf(l), c >= 0 ? (this.lastItem = this.list[c], true) : false);
      }, a2.prototype.forEach = function(l, c) {
        var d;
        for (d = 0; d < this.size; d++)
          l.call(c || this, this.list[d].val, this.list[d].key, this);
      }, a2.prototype.indexOf = function(l) {
        var c;
        for (c = 0; c < this.size; c++)
          if (this.isEqual(this.list[c].key, l))
            return c;
        return -1;
      }, a2.prototype.isEqual = function(l, c) {
        return l === c || l !== l && c !== c;
      }, n3.exports = a2;
    }, {}], 3: [function(o2, n3, i) {
      var a2 = o2("map-or-similar");
      n3.exports = function(p4) {
        var u2 = new a2(false), y2 = [];
        return function(m3) {
          var g = s3(function() {
            var S4 = u2, h, E2, R4 = arguments.length - 1, f5 = Array(R4 + 1), b5 = true, x5;
            if ((g.numArgs || g.numArgs === 0) && g.numArgs !== R4 + 1)
              throw new Error("Memoizerific functions should always be called with the same number of arguments");
            for (x5 = 0; x5 < R4; x5++) {
              if (f5[x5] = {
                cacheItem: S4,
                arg: arguments[x5]
              }, S4.has(arguments[x5])) {
                S4 = S4.get(arguments[x5]);
                continue;
              }
              b5 = false, h = new a2(false), S4.set(arguments[x5], h), S4 = h;
            }
            return b5 && (S4.has(arguments[R4]) ? E2 = S4.get(arguments[R4]) : b5 = false), b5 || (E2 = m3.apply(null, arguments), S4.set(arguments[R4], E2)), p4 > 0 && (f5[R4] = {
              cacheItem: S4,
              arg: arguments[R4]
            }, b5 ? l(y2, f5) : y2.push(f5), y2.length > p4 && c(y2.shift())), g.wasMemoized = b5, g.numArgs = R4 + 1, E2;
          }, "memoizerific");
          return g.limit = p4, g.wasMemoized = false, g.cache = u2, g.lru = y2, g;
        };
      };
      function l(p4, u2) {
        var y2 = p4.length, m3 = u2.length, g, S4, h;
        for (S4 = 0; S4 < y2; S4++) {
          for (g = true, h = 0; h < m3; h++)
            if (!d(p4[S4][h].arg, u2[h].arg)) {
              g = false;
              break;
            }
          if (g)
            break;
        }
        p4.push(p4.splice(S4, 1)[0]);
      }
      s3(l, "moveToMostRecentLru");
      function c(p4) {
        var u2 = p4.length, y2 = p4[u2 - 1], m3, g;
        for (y2.cacheItem.delete(y2.arg), g = u2 - 2; g >= 0 && (y2 = p4[g], m3 = y2.cacheItem.get(y2.arg), !m3 || !m3.size); g--)
          y2.cacheItem.delete(y2.arg);
      }
      s3(c, "removeCachedResult");
      function d(p4, u2) {
        return p4 === u2 || p4 !== p4 && u2 !== u2;
      }
      s3(d, "isEqual");
    }, { "map-or-similar": 1 }] }, {}, [3])(3);
  });
});
var dt = k4((ct) => {
  "use strict";
  Object.defineProperty(ct, "__esModule", { value: true });
  ct.encodeString = ta;
  var H3 = Array.from({ length: 256 }, (r3, e2) => "%" + ((e2 < 16 ? "0" : "") + e2.toString(16)).toUpperCase()), ra = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  function ta(r3) {
    let e2 = r3.length;
    if (e2 === 0)
      return "";
    let t3 = "", o2 = 0, n3 = 0;
    e: for (; n3 < e2; n3++) {
      let i = r3.charCodeAt(n3);
      for (; i < 128; ) {
        if (ra[i] !== 1 && (o2 < n3 && (t3 += r3.slice(o2, n3)), o2 = n3 + 1, t3 += H3[i]), ++n3 === e2)
          break e;
        i = r3.charCodeAt(n3);
      }
      if (o2 < n3 && (t3 += r3.slice(o2, n3)), i < 2048) {
        o2 = n3 + 1, t3 += H3[192 | i >> 6] + H3[128 | i & 63];
        continue;
      }
      if (i < 55296 || i >= 57344) {
        o2 = n3 + 1, t3 += H3[224 | i >> 12] + H3[128 | i >> 6 & 63] + H3[128 | i & 63];
        continue;
      }
      if (++n3, n3 >= e2)
        throw new Error("URI malformed");
      let a2 = r3.charCodeAt(n3) & 1023;
      o2 = n3 + 1, i = 65536 + ((i & 1023) << 10 | a2), t3 += H3[240 | i >> 18] + H3[128 | i >> 12 & 63] + H3[128 | i >> 6 & 63] + H3[128 | i & 63];
    }
    return o2 === 0 ? r3 : o2 < e2 ? t3 + r3.slice(o2) : t3;
  }
  s3(ta, "encodeString");
});
var sr = k4((W5) => {
  "use strict";
  Object.defineProperty(W5, "__esModule", { value: true });
  W5.defaultOptions = W5.defaultShouldSerializeObject = W5.defaultValueSerializer = void 0;
  var pt = dt(), oa = s3((r3) => {
    switch (typeof r3) {
      case "string":
        return (0, pt.encodeString)(r3);
      case "bigint":
      case "boolean":
        return "" + r3;
      case "number":
        if (Number.isFinite(r3))
          return r3 < 1e21 ? "" + r3 : (0, pt.encodeString)("" + r3);
        break;
    }
    return r3 instanceof Date ? (0, pt.encodeString)(r3.toISOString()) : "";
  }, "defaultValueSerializer");
  W5.defaultValueSerializer = oa;
  var na = s3((r3) => r3 instanceof Date, "defaultShouldSerializeObject");
  W5.defaultShouldSerializeObject = na;
  var Bo = s3((r3) => r3, "identityFunc");
  W5.defaultOptions = {
    nesting: true,
    nestingSyntax: "dot",
    arrayRepeat: false,
    arrayRepeatSyntax: "repeat",
    delimiter: 38,
    valueDeserializer: Bo,
    valueSerializer: W5.defaultValueSerializer,
    keyDeserializer: Bo,
    shouldSerializeObject: W5.defaultShouldSerializeObject
  };
});
var ut = k4((ir) => {
  "use strict";
  Object.defineProperty(ir, "__esModule", { value: true });
  ir.getDeepObject = aa;
  ir.stringifyObject = zo;
  var de = sr(), sa = dt();
  function ia(r3) {
    return r3 === "__proto__" || r3 === "constructor" || r3 === "prototype";
  }
  s3(ia, "isPrototypeKey");
  function aa(r3, e2, t3, o2, n3) {
    if (ia(e2))
      return r3;
    let i = r3[e2];
    return typeof i == "object" && i !== null ? i : !o2 && (n3 || typeof t3 == "number" || typeof t3 == "string" && t3 * 0 === 0 && t3.indexOf(".") === -1) ? r3[e2] = [] : r3[e2] = {};
  }
  s3(aa, "getDeepObject");
  var la = 20, ca = "[]", da = "[", pa = "]", ua = ".";
  function zo(r3, e2, t3 = 0, o2, n3) {
    let { nestingSyntax: i = de.defaultOptions.nestingSyntax, arrayRepeat: a2 = de.defaultOptions.arrayRepeat, arrayRepeatSyntax: l = de.defaultOptions.arrayRepeatSyntax, nesting: c = de.defaultOptions.nesting, delimiter: d = de.defaultOptions.delimiter, valueSerializer: p4 = de.defaultOptions.valueSerializer, shouldSerializeObject: u2 = de.defaultOptions.shouldSerializeObject } = e2, y2 = typeof d == "number" ? String.fromCharCode(
      d
    ) : d, m3 = n3 === true && a2, g = i === "dot" || i === "js" && !n3;
    if (t3 > la)
      return "";
    let S4 = "", h = true, E2 = false;
    for (let R4 in r3) {
      let f5 = r3[R4], b5;
      o2 ? (b5 = o2, m3 ? l === "bracket" && (b5 += ca) : g ? (b5 += ua, b5 += R4) : (b5 += da, b5 += R4, b5 += pa)) : b5 = R4, h || (S4 += y2), typeof f5 == "object" && f5 !== null && !u2(f5) ? (E2 = f5.pop !== void 0, (c || a2 && E2) && (S4 += zo(f5, e2, t3 + 1, b5, E2))) : (S4 += (0, sa.encodeString)(b5), S4 += "=", S4 += p4(f5, R4)), h && (h = false);
    }
    return S4;
  }
  s3(zo, "stringifyObject");
});
var $o = k4((df, Wo) => {
  "use strict";
  var Vo = 12, fa = 0, ft = [
    // The first part of the table maps bytes to character to a transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    // The second part of the table maps a state to a new state when adding a
    // transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // The third part maps the current transition to a mask that needs to apply
    // to the byte.
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function ya(r3) {
    var e2 = r3.indexOf("%");
    if (e2 === -1) return r3;
    for (var t3 = r3.length, o2 = "", n3 = 0, i = 0, a2 = e2, l = Vo; e2 > -1 && e2 < t3; ) {
      var c = Ho(r3[e2 + 1], 4), d = Ho(r3[e2 + 2], 0), p4 = c | d, u2 = ft[p4];
      if (l = ft[256 + l + u2], i = i << 6 | p4 & ft[364 + u2], l === Vo)
        o2 += r3.slice(n3, a2), o2 += i <= 65535 ? String.fromCharCode(i) : String.fromCharCode(
          55232 + (i >> 10),
          56320 + (i & 1023)
        ), i = 0, n3 = e2 + 3, e2 = a2 = r3.indexOf("%", n3);
      else {
        if (l === fa)
          return null;
        if (e2 += 3, e2 < t3 && r3.charCodeAt(e2) === 37) continue;
        return null;
      }
    }
    return o2 + r3.slice(n3);
  }
  s3(ya, "decodeURIComponent");
  var ha = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function Ho(r3, e2) {
    var t3 = ha[r3];
    return t3 === void 0 ? 255 : t3 << e2;
  }
  s3(Ho, "hexCodeToInt");
  Wo.exports = ya;
});
var Jo = k4((X3) => {
  "use strict";
  var ma = X3 && X3.__importDefault || function(r3) {
    return r3 && r3.__esModule ? r3 : { default: r3 };
  };
  Object.defineProperty(X3, "__esModule", { value: true });
  X3.numberValueDeserializer = X3.numberKeyDeserializer = void 0;
  X3.parse = ba;
  var ar = ut(), pe = sr(), Yo = ma($o()), ga = s3((r3) => {
    let e2 = Number(r3);
    return Number.isNaN(e2) ? r3 : e2;
  }, "numberKeyDeserializer");
  X3.numberKeyDeserializer = ga;
  var Sa = s3((r3) => {
    let e2 = Number(r3);
    return Number.isNaN(e2) ? r3 : e2;
  }, "numberValueDeserializer");
  X3.numberValueDeserializer = Sa;
  var Ko = /\+/g, Xo = s3(function() {
  }, "Empty");
  Xo.prototype = /* @__PURE__ */ Object.create(null);
  function lr(r3, e2, t3, o2, n3) {
    let i = r3.substring(e2, t3);
    return o2 && (i = i.replace(Ko, " ")), n3 && (i = (0, Yo.default)(i) || i), i;
  }
  s3(lr, "computeKeySlice");
  function ba(r3, e2) {
    let { valueDeserializer: t3 = pe.defaultOptions.valueDeserializer, keyDeserializer: o2 = pe.defaultOptions.keyDeserializer, arrayRepeatSyntax: n3 = pe.defaultOptions.arrayRepeatSyntax, nesting: i = pe.defaultOptions.nesting, arrayRepeat: a2 = pe.defaultOptions.arrayRepeat, nestingSyntax: l = pe.defaultOptions.nestingSyntax, delimiter: c = pe.defaultOptions.delimiter } = e2 ?? {}, d = typeof c == "string" ? c.charCodeAt(0) : c, p4 = l === "js", u2 = new Xo();
    if (typeof r3 != "string")
      return u2;
    let y2 = r3.length, m3 = "", g = -1, S4 = -1, h = -1, E2 = u2, R4, f5 = "", b5 = "", x5 = false, w5 = false, A3 = false, O4 = false, N4 = false, U4 = false, ye = false, C3 = 0, z4 = -1, Ce = -1, Pt = -1;
    for (let D4 = 0; D4 < y2 + 1; D4++) {
      if (C3 = D4 !== y2 ? r3.charCodeAt(D4) : d, C3 === d) {
        if (ye = S4 > g, ye || (S4 = D4), h !== S4 - 1 && (b5 = lr(r3, h + 1, z4 > -1 ? z4 : S4, A3, x5), f5 = o2(b5), R4 !== void 0 && (E2 = (0, ar.getDeepObject)(
          E2,
          R4,
          f5,
          p4 && N4,
          p4 && U4
        ))), ye || f5 !== "") {
          ye && (m3 = r3.slice(S4 + 1, D4), O4 && (m3 = m3.replace(Ko, " ")), w5 && (m3 = (0, Yo.default)(m3) || m3));
          let Pe = t3(m3, f5);
          if (a2) {
            let Ve = E2[f5];
            Ve === void 0 ? z4 > -1 ? E2[f5] = [Pe] : E2[f5] = Pe : Ve.pop ? Ve.push(Pe) : E2[f5] = [Ve, Pe];
          } else
            E2[f5] = Pe;
        }
        m3 = "", g = D4, S4 = D4, x5 = false, w5 = false, A3 = false, O4 = false, N4 = false, U4 = false, z4 = -1, h = D4, E2 = u2, R4 = void 0, f5 = "";
      } else C3 === 93 ? (a2 && n3 === "bracket" && Pt === 91 && (z4 = Ce), i && (l === "index" || p4) && S4 <= g && (h !== Ce && (b5 = lr(
        r3,
        h + 1,
        D4,
        A3,
        x5
      ), f5 = o2(b5), R4 !== void 0 && (E2 = (0, ar.getDeepObject)(E2, R4, f5, void 0, p4)), R4 = f5, A3 = false, x5 = false), h = D4, U4 = true, N4 = false)) : C3 === 46 ? i && (l === "dot" || p4) && S4 <= g && (h !== Ce && (b5 = lr(r3, h + 1, D4, A3, x5), f5 = o2(b5), R4 !== void 0 && (E2 = (0, ar.getDeepObject)(
        E2,
        R4,
        f5,
        p4
      )), R4 = f5, A3 = false, x5 = false), N4 = true, U4 = false, h = D4) : C3 === 91 ? i && (l === "index" || p4) && S4 <= g && (h !== Ce && (b5 = lr(
        r3,
        h + 1,
        D4,
        A3,
        x5
      ), f5 = o2(b5), p4 && R4 !== void 0 && (E2 = (0, ar.getDeepObject)(E2, R4, f5, p4)), R4 = f5, A3 = false, x5 = false, N4 = false, U4 = true), h = D4) : C3 === 61 ? S4 <= g ? S4 = D4 : w5 = true : C3 === 43 ? S4 > g ? O4 = true : A3 = true : C3 === 37 && (S4 > g ? w5 = true : x5 = true);
      Ce = D4, Pt = C3;
    }
    return u2;
  }
  s3(ba, "parse");
});
var Qo = k4((yt) => {
  "use strict";
  Object.defineProperty(yt, "__esModule", { value: true });
  yt.stringify = Ea;
  var Ta = ut();
  function Ea(r3, e2) {
    if (r3 === null || typeof r3 != "object")
      return "";
    let t3 = e2 ?? {};
    return (0, Ta.stringifyObject)(r3, t3);
  }
  s3(Ea, "stringify");
});
var cr = k4((B3) => {
  "use strict";
  var Ra = B3 && B3.__createBinding || (Object.create ? function(r3, e2, t3, o2) {
    o2 === void 0 && (o2 = t3);
    var n3 = Object.getOwnPropertyDescriptor(e2, t3);
    (!n3 || ("get" in n3 ? !e2.__esModule : n3.writable || n3.configurable)) && (n3 = { enumerable: true, get: s3(function() {
      return e2[t3];
    }, "get") }), Object.defineProperty(r3, o2, n3);
  } : function(r3, e2, t3, o2) {
    o2 === void 0 && (o2 = t3), r3[o2] = e2[t3];
  }), xa = B3 && B3.__exportStar || function(r3, e2) {
    for (var t3 in r3) t3 !== "default" && !Object.prototype.hasOwnProperty.call(e2, t3) && Ra(e2, r3, t3);
  };
  Object.defineProperty(B3, "__esModule", { value: true });
  B3.stringify = B3.parse = void 0;
  var wa = Jo();
  Object.defineProperty(B3, "parse", { enumerable: true, get: s3(function() {
    return wa.parse;
  }, "get") });
  var va = Qo();
  Object.defineProperty(B3, "stringify", { enumerable: true, get: s3(function() {
    return va.stringify;
  }, "get") });
  xa(sr(), B3);
});
var St = k4((Cf, ka) => {
  ka.exports = {
    Aacute: "Á",
    aacute: "á",
    Abreve: "Ă",
    abreve: "ă",
    ac: "∾",
    acd: "∿",
    acE: "∾̳",
    Acirc: "Â",
    acirc: "â",
    acute: "´",
    Acy: "А",
    acy: "а",
    AElig: "Æ",
    aelig: "æ",
    af: "⁡",
    Afr: "𝔄",
    afr: "𝔞",
    Agrave: "À",
    agrave: "à",
    alefsym: "ℵ",
    aleph: "ℵ",
    Alpha: "Α",
    alpha: "α",
    Amacr: "Ā",
    amacr: "ā",
    amalg: "⨿",
    amp: "&",
    AMP: "&",
    andand: "⩕",
    And: "⩓",
    and: "∧",
    andd: "⩜",
    andslope: "⩘",
    andv: "⩚",
    ang: "∠",
    ange: "⦤",
    angle: "∠",
    angmsdaa: "⦨",
    angmsdab: "⦩",
    angmsdac: "⦪",
    angmsdad: "⦫",
    angmsdae: "⦬",
    angmsdaf: "⦭",
    angmsdag: "⦮",
    angmsdah: "⦯",
    angmsd: "∡",
    angrt: "∟",
    angrtvb: "⊾",
    angrtvbd: "⦝",
    angsph: "∢",
    angst: "Å",
    angzarr: "⍼",
    Aogon: "Ą",
    aogon: "ą",
    Aopf: "𝔸",
    aopf: "𝕒",
    apacir: "⩯",
    ap: "≈",
    apE: "⩰",
    ape: "≊",
    apid: "≋",
    apos: "'",
    ApplyFunction: "⁡",
    approx: "≈",
    approxeq: "≊",
    Aring: "Å",
    aring: "å",
    Ascr: "𝒜",
    ascr: "𝒶",
    Assign: "≔",
    ast: "*",
    asymp: "≈",
    asympeq: "≍",
    Atilde: "Ã",
    atilde: "ã",
    Auml: "Ä",
    auml: "ä",
    awconint: "∳",
    awint: "⨑",
    backcong: "≌",
    backepsilon: "϶",
    backprime: "‵",
    backsim: "∽",
    backsimeq: "⋍",
    Backslash: "∖",
    Barv: "⫧",
    barvee: "⊽",
    barwed: "⌅",
    Barwed: "⌆",
    barwedge: "⌅",
    bbrk: "⎵",
    bbrktbrk: "⎶",
    bcong: "≌",
    Bcy: "Б",
    bcy: "б",
    bdquo: "„",
    becaus: "∵",
    because: "∵",
    Because: "∵",
    bemptyv: "⦰",
    bepsi: "϶",
    bernou: "ℬ",
    Bernoullis: "ℬ",
    Beta: "Β",
    beta: "β",
    beth: "ℶ",
    between: "≬",
    Bfr: "𝔅",
    bfr: "𝔟",
    bigcap: "⋂",
    bigcirc: "◯",
    bigcup: "⋃",
    bigodot: "⨀",
    bigoplus: "⨁",
    bigotimes: "⨂",
    bigsqcup: "⨆",
    bigstar: "★",
    bigtriangledown: "▽",
    bigtriangleup: "△",
    biguplus: "⨄",
    bigvee: "⋁",
    bigwedge: "⋀",
    bkarow: "⤍",
    blacklozenge: "⧫",
    blacksquare: "▪",
    blacktriangle: "▴",
    blacktriangledown: "▾",
    blacktriangleleft: "◂",
    blacktriangleright: "▸",
    blank: "␣",
    blk12: "▒",
    blk14: "░",
    blk34: "▓",
    block: "█",
    bne: "=⃥",
    bnequiv: "≡⃥",
    bNot: "⫭",
    bnot: "⌐",
    Bopf: "𝔹",
    bopf: "𝕓",
    bot: "⊥",
    bottom: "⊥",
    bowtie: "⋈",
    boxbox: "⧉",
    boxdl: "┐",
    boxdL: "╕",
    boxDl: "╖",
    boxDL: "╗",
    boxdr: "┌",
    boxdR: "╒",
    boxDr: "╓",
    boxDR: "╔",
    boxh: "─",
    boxH: "═",
    boxhd: "┬",
    boxHd: "╤",
    boxhD: "╥",
    boxHD: "╦",
    boxhu: "┴",
    boxHu: "╧",
    boxhU: "╨",
    boxHU: "╩",
    boxminus: "⊟",
    boxplus: "⊞",
    boxtimes: "⊠",
    boxul: "┘",
    boxuL: "╛",
    boxUl: "╜",
    boxUL: "╝",
    boxur: "└",
    boxuR: "╘",
    boxUr: "╙",
    boxUR: "╚",
    boxv: "│",
    boxV: "║",
    boxvh: "┼",
    boxvH: "╪",
    boxVh: "╫",
    boxVH: "╬",
    boxvl: "┤",
    boxvL: "╡",
    boxVl: "╢",
    boxVL: "╣",
    boxvr: "├",
    boxvR: "╞",
    boxVr: "╟",
    boxVR: "╠",
    bprime: "‵",
    breve: "˘",
    Breve: "˘",
    brvbar: "¦",
    bscr: "𝒷",
    Bscr: "ℬ",
    bsemi: "⁏",
    bsim: "∽",
    bsime: "⋍",
    bsolb: "⧅",
    bsol: "\\",
    bsolhsub: "⟈",
    bull: "•",
    bullet: "•",
    bump: "≎",
    bumpE: "⪮",
    bumpe: "≏",
    Bumpeq: "≎",
    bumpeq: "≏",
    Cacute: "Ć",
    cacute: "ć",
    capand: "⩄",
    capbrcup: "⩉",
    capcap: "⩋",
    cap: "∩",
    Cap: "⋒",
    capcup: "⩇",
    capdot: "⩀",
    CapitalDifferentialD: "ⅅ",
    caps: "∩︀",
    caret: "⁁",
    caron: "ˇ",
    Cayleys: "ℭ",
    ccaps: "⩍",
    Ccaron: "Č",
    ccaron: "č",
    Ccedil: "Ç",
    ccedil: "ç",
    Ccirc: "Ĉ",
    ccirc: "ĉ",
    Cconint: "∰",
    ccups: "⩌",
    ccupssm: "⩐",
    Cdot: "Ċ",
    cdot: "ċ",
    cedil: "¸",
    Cedilla: "¸",
    cemptyv: "⦲",
    cent: "¢",
    centerdot: "·",
    CenterDot: "·",
    cfr: "𝔠",
    Cfr: "ℭ",
    CHcy: "Ч",
    chcy: "ч",
    check: "✓",
    checkmark: "✓",
    Chi: "Χ",
    chi: "χ",
    circ: "ˆ",
    circeq: "≗",
    circlearrowleft: "↺",
    circlearrowright: "↻",
    circledast: "⊛",
    circledcirc: "⊚",
    circleddash: "⊝",
    CircleDot: "⊙",
    circledR: "®",
    circledS: "Ⓢ",
    CircleMinus: "⊖",
    CirclePlus: "⊕",
    CircleTimes: "⊗",
    cir: "○",
    cirE: "⧃",
    cire: "≗",
    cirfnint: "⨐",
    cirmid: "⫯",
    cirscir: "⧂",
    ClockwiseContourIntegral: "∲",
    CloseCurlyDoubleQuote: "”",
    CloseCurlyQuote: "’",
    clubs: "♣",
    clubsuit: "♣",
    colon: ":",
    Colon: "∷",
    Colone: "⩴",
    colone: "≔",
    coloneq: "≔",
    comma: ",",
    commat: "@",
    comp: "∁",
    compfn: "∘",
    complement: "∁",
    complexes: "ℂ",
    cong: "≅",
    congdot: "⩭",
    Congruent: "≡",
    conint: "∮",
    Conint: "∯",
    ContourIntegral: "∮",
    copf: "𝕔",
    Copf: "ℂ",
    coprod: "∐",
    Coproduct: "∐",
    copy: "©",
    COPY: "©",
    copysr: "℗",
    CounterClockwiseContourIntegral: "∳",
    crarr: "↵",
    cross: "✗",
    Cross: "⨯",
    Cscr: "𝒞",
    cscr: "𝒸",
    csub: "⫏",
    csube: "⫑",
    csup: "⫐",
    csupe: "⫒",
    ctdot: "⋯",
    cudarrl: "⤸",
    cudarrr: "⤵",
    cuepr: "⋞",
    cuesc: "⋟",
    cularr: "↶",
    cularrp: "⤽",
    cupbrcap: "⩈",
    cupcap: "⩆",
    CupCap: "≍",
    cup: "∪",
    Cup: "⋓",
    cupcup: "⩊",
    cupdot: "⊍",
    cupor: "⩅",
    cups: "∪︀",
    curarr: "↷",
    curarrm: "⤼",
    curlyeqprec: "⋞",
    curlyeqsucc: "⋟",
    curlyvee: "⋎",
    curlywedge: "⋏",
    curren: "¤",
    curvearrowleft: "↶",
    curvearrowright: "↷",
    cuvee: "⋎",
    cuwed: "⋏",
    cwconint: "∲",
    cwint: "∱",
    cylcty: "⌭",
    dagger: "†",
    Dagger: "‡",
    daleth: "ℸ",
    darr: "↓",
    Darr: "↡",
    dArr: "⇓",
    dash: "‐",
    Dashv: "⫤",
    dashv: "⊣",
    dbkarow: "⤏",
    dblac: "˝",
    Dcaron: "Ď",
    dcaron: "ď",
    Dcy: "Д",
    dcy: "д",
    ddagger: "‡",
    ddarr: "⇊",
    DD: "ⅅ",
    dd: "ⅆ",
    DDotrahd: "⤑",
    ddotseq: "⩷",
    deg: "°",
    Del: "∇",
    Delta: "Δ",
    delta: "δ",
    demptyv: "⦱",
    dfisht: "⥿",
    Dfr: "𝔇",
    dfr: "𝔡",
    dHar: "⥥",
    dharl: "⇃",
    dharr: "⇂",
    DiacriticalAcute: "´",
    DiacriticalDot: "˙",
    DiacriticalDoubleAcute: "˝",
    DiacriticalGrave: "`",
    DiacriticalTilde: "˜",
    diam: "⋄",
    diamond: "⋄",
    Diamond: "⋄",
    diamondsuit: "♦",
    diams: "♦",
    die: "¨",
    DifferentialD: "ⅆ",
    digamma: "ϝ",
    disin: "⋲",
    div: "÷",
    divide: "÷",
    divideontimes: "⋇",
    divonx: "⋇",
    DJcy: "Ђ",
    djcy: "ђ",
    dlcorn: "⌞",
    dlcrop: "⌍",
    dollar: "$",
    Dopf: "𝔻",
    dopf: "𝕕",
    Dot: "¨",
    dot: "˙",
    DotDot: "⃜",
    doteq: "≐",
    doteqdot: "≑",
    DotEqual: "≐",
    dotminus: "∸",
    dotplus: "∔",
    dotsquare: "⊡",
    doublebarwedge: "⌆",
    DoubleContourIntegral: "∯",
    DoubleDot: "¨",
    DoubleDownArrow: "⇓",
    DoubleLeftArrow: "⇐",
    DoubleLeftRightArrow: "⇔",
    DoubleLeftTee: "⫤",
    DoubleLongLeftArrow: "⟸",
    DoubleLongLeftRightArrow: "⟺",
    DoubleLongRightArrow: "⟹",
    DoubleRightArrow: "⇒",
    DoubleRightTee: "⊨",
    DoubleUpArrow: "⇑",
    DoubleUpDownArrow: "⇕",
    DoubleVerticalBar: "∥",
    DownArrowBar: "⤓",
    downarrow: "↓",
    DownArrow: "↓",
    Downarrow: "⇓",
    DownArrowUpArrow: "⇵",
    DownBreve: "̑",
    downdownarrows: "⇊",
    downharpoonleft: "⇃",
    downharpoonright: "⇂",
    DownLeftRightVector: "⥐",
    DownLeftTeeVector: "⥞",
    DownLeftVectorBar: "⥖",
    DownLeftVector: "↽",
    DownRightTeeVector: "⥟",
    DownRightVectorBar: "⥗",
    DownRightVector: "⇁",
    DownTeeArrow: "↧",
    DownTee: "⊤",
    drbkarow: "⤐",
    drcorn: "⌟",
    drcrop: "⌌",
    Dscr: "𝒟",
    dscr: "𝒹",
    DScy: "Ѕ",
    dscy: "ѕ",
    dsol: "⧶",
    Dstrok: "Đ",
    dstrok: "đ",
    dtdot: "⋱",
    dtri: "▿",
    dtrif: "▾",
    duarr: "⇵",
    duhar: "⥯",
    dwangle: "⦦",
    DZcy: "Џ",
    dzcy: "џ",
    dzigrarr: "⟿",
    Eacute: "É",
    eacute: "é",
    easter: "⩮",
    Ecaron: "Ě",
    ecaron: "ě",
    Ecirc: "Ê",
    ecirc: "ê",
    ecir: "≖",
    ecolon: "≕",
    Ecy: "Э",
    ecy: "э",
    eDDot: "⩷",
    Edot: "Ė",
    edot: "ė",
    eDot: "≑",
    ee: "ⅇ",
    efDot: "≒",
    Efr: "𝔈",
    efr: "𝔢",
    eg: "⪚",
    Egrave: "È",
    egrave: "è",
    egs: "⪖",
    egsdot: "⪘",
    el: "⪙",
    Element: "∈",
    elinters: "⏧",
    ell: "ℓ",
    els: "⪕",
    elsdot: "⪗",
    Emacr: "Ē",
    emacr: "ē",
    empty: "∅",
    emptyset: "∅",
    EmptySmallSquare: "◻",
    emptyv: "∅",
    EmptyVerySmallSquare: "▫",
    emsp13: " ",
    emsp14: " ",
    emsp: " ",
    ENG: "Ŋ",
    eng: "ŋ",
    ensp: " ",
    Eogon: "Ę",
    eogon: "ę",
    Eopf: "𝔼",
    eopf: "𝕖",
    epar: "⋕",
    eparsl: "⧣",
    eplus: "⩱",
    epsi: "ε",
    Epsilon: "Ε",
    epsilon: "ε",
    epsiv: "ϵ",
    eqcirc: "≖",
    eqcolon: "≕",
    eqsim: "≂",
    eqslantgtr: "⪖",
    eqslantless: "⪕",
    Equal: "⩵",
    equals: "=",
    EqualTilde: "≂",
    equest: "≟",
    Equilibrium: "⇌",
    equiv: "≡",
    equivDD: "⩸",
    eqvparsl: "⧥",
    erarr: "⥱",
    erDot: "≓",
    escr: "ℯ",
    Escr: "ℰ",
    esdot: "≐",
    Esim: "⩳",
    esim: "≂",
    Eta: "Η",
    eta: "η",
    ETH: "Ð",
    eth: "ð",
    Euml: "Ë",
    euml: "ë",
    euro: "€",
    excl: "!",
    exist: "∃",
    Exists: "∃",
    expectation: "ℰ",
    exponentiale: "ⅇ",
    ExponentialE: "ⅇ",
    fallingdotseq: "≒",
    Fcy: "Ф",
    fcy: "ф",
    female: "♀",
    ffilig: "ﬃ",
    fflig: "ﬀ",
    ffllig: "ﬄ",
    Ffr: "𝔉",
    ffr: "𝔣",
    filig: "ﬁ",
    FilledSmallSquare: "◼",
    FilledVerySmallSquare: "▪",
    fjlig: "fj",
    flat: "♭",
    fllig: "ﬂ",
    fltns: "▱",
    fnof: "ƒ",
    Fopf: "𝔽",
    fopf: "𝕗",
    forall: "∀",
    ForAll: "∀",
    fork: "⋔",
    forkv: "⫙",
    Fouriertrf: "ℱ",
    fpartint: "⨍",
    frac12: "½",
    frac13: "⅓",
    frac14: "¼",
    frac15: "⅕",
    frac16: "⅙",
    frac18: "⅛",
    frac23: "⅔",
    frac25: "⅖",
    frac34: "¾",
    frac35: "⅗",
    frac38: "⅜",
    frac45: "⅘",
    frac56: "⅚",
    frac58: "⅝",
    frac78: "⅞",
    frasl: "⁄",
    frown: "⌢",
    fscr: "𝒻",
    Fscr: "ℱ",
    gacute: "ǵ",
    Gamma: "Γ",
    gamma: "γ",
    Gammad: "Ϝ",
    gammad: "ϝ",
    gap: "⪆",
    Gbreve: "Ğ",
    gbreve: "ğ",
    Gcedil: "Ģ",
    Gcirc: "Ĝ",
    gcirc: "ĝ",
    Gcy: "Г",
    gcy: "г",
    Gdot: "Ġ",
    gdot: "ġ",
    ge: "≥",
    gE: "≧",
    gEl: "⪌",
    gel: "⋛",
    geq: "≥",
    geqq: "≧",
    geqslant: "⩾",
    gescc: "⪩",
    ges: "⩾",
    gesdot: "⪀",
    gesdoto: "⪂",
    gesdotol: "⪄",
    gesl: "⋛︀",
    gesles: "⪔",
    Gfr: "𝔊",
    gfr: "𝔤",
    gg: "≫",
    Gg: "⋙",
    ggg: "⋙",
    gimel: "ℷ",
    GJcy: "Ѓ",
    gjcy: "ѓ",
    gla: "⪥",
    gl: "≷",
    glE: "⪒",
    glj: "⪤",
    gnap: "⪊",
    gnapprox: "⪊",
    gne: "⪈",
    gnE: "≩",
    gneq: "⪈",
    gneqq: "≩",
    gnsim: "⋧",
    Gopf: "𝔾",
    gopf: "𝕘",
    grave: "`",
    GreaterEqual: "≥",
    GreaterEqualLess: "⋛",
    GreaterFullEqual: "≧",
    GreaterGreater: "⪢",
    GreaterLess: "≷",
    GreaterSlantEqual: "⩾",
    GreaterTilde: "≳",
    Gscr: "𝒢",
    gscr: "ℊ",
    gsim: "≳",
    gsime: "⪎",
    gsiml: "⪐",
    gtcc: "⪧",
    gtcir: "⩺",
    gt: ">",
    GT: ">",
    Gt: "≫",
    gtdot: "⋗",
    gtlPar: "⦕",
    gtquest: "⩼",
    gtrapprox: "⪆",
    gtrarr: "⥸",
    gtrdot: "⋗",
    gtreqless: "⋛",
    gtreqqless: "⪌",
    gtrless: "≷",
    gtrsim: "≳",
    gvertneqq: "≩︀",
    gvnE: "≩︀",
    Hacek: "ˇ",
    hairsp: " ",
    half: "½",
    hamilt: "ℋ",
    HARDcy: "Ъ",
    hardcy: "ъ",
    harrcir: "⥈",
    harr: "↔",
    hArr: "⇔",
    harrw: "↭",
    Hat: "^",
    hbar: "ℏ",
    Hcirc: "Ĥ",
    hcirc: "ĥ",
    hearts: "♥",
    heartsuit: "♥",
    hellip: "…",
    hercon: "⊹",
    hfr: "𝔥",
    Hfr: "ℌ",
    HilbertSpace: "ℋ",
    hksearow: "⤥",
    hkswarow: "⤦",
    hoarr: "⇿",
    homtht: "∻",
    hookleftarrow: "↩",
    hookrightarrow: "↪",
    hopf: "𝕙",
    Hopf: "ℍ",
    horbar: "―",
    HorizontalLine: "─",
    hscr: "𝒽",
    Hscr: "ℋ",
    hslash: "ℏ",
    Hstrok: "Ħ",
    hstrok: "ħ",
    HumpDownHump: "≎",
    HumpEqual: "≏",
    hybull: "⁃",
    hyphen: "‐",
    Iacute: "Í",
    iacute: "í",
    ic: "⁣",
    Icirc: "Î",
    icirc: "î",
    Icy: "И",
    icy: "и",
    Idot: "İ",
    IEcy: "Е",
    iecy: "е",
    iexcl: "¡",
    iff: "⇔",
    ifr: "𝔦",
    Ifr: "ℑ",
    Igrave: "Ì",
    igrave: "ì",
    ii: "ⅈ",
    iiiint: "⨌",
    iiint: "∭",
    iinfin: "⧜",
    iiota: "℩",
    IJlig: "Ĳ",
    ijlig: "ĳ",
    Imacr: "Ī",
    imacr: "ī",
    image: "ℑ",
    ImaginaryI: "ⅈ",
    imagline: "ℐ",
    imagpart: "ℑ",
    imath: "ı",
    Im: "ℑ",
    imof: "⊷",
    imped: "Ƶ",
    Implies: "⇒",
    incare: "℅",
    in: "∈",
    infin: "∞",
    infintie: "⧝",
    inodot: "ı",
    intcal: "⊺",
    int: "∫",
    Int: "∬",
    integers: "ℤ",
    Integral: "∫",
    intercal: "⊺",
    Intersection: "⋂",
    intlarhk: "⨗",
    intprod: "⨼",
    InvisibleComma: "⁣",
    InvisibleTimes: "⁢",
    IOcy: "Ё",
    iocy: "ё",
    Iogon: "Į",
    iogon: "į",
    Iopf: "𝕀",
    iopf: "𝕚",
    Iota: "Ι",
    iota: "ι",
    iprod: "⨼",
    iquest: "¿",
    iscr: "𝒾",
    Iscr: "ℐ",
    isin: "∈",
    isindot: "⋵",
    isinE: "⋹",
    isins: "⋴",
    isinsv: "⋳",
    isinv: "∈",
    it: "⁢",
    Itilde: "Ĩ",
    itilde: "ĩ",
    Iukcy: "І",
    iukcy: "і",
    Iuml: "Ï",
    iuml: "ï",
    Jcirc: "Ĵ",
    jcirc: "ĵ",
    Jcy: "Й",
    jcy: "й",
    Jfr: "𝔍",
    jfr: "𝔧",
    jmath: "ȷ",
    Jopf: "𝕁",
    jopf: "𝕛",
    Jscr: "𝒥",
    jscr: "𝒿",
    Jsercy: "Ј",
    jsercy: "ј",
    Jukcy: "Є",
    jukcy: "є",
    Kappa: "Κ",
    kappa: "κ",
    kappav: "ϰ",
    Kcedil: "Ķ",
    kcedil: "ķ",
    Kcy: "К",
    kcy: "к",
    Kfr: "𝔎",
    kfr: "𝔨",
    kgreen: "ĸ",
    KHcy: "Х",
    khcy: "х",
    KJcy: "Ќ",
    kjcy: "ќ",
    Kopf: "𝕂",
    kopf: "𝕜",
    Kscr: "𝒦",
    kscr: "𝓀",
    lAarr: "⇚",
    Lacute: "Ĺ",
    lacute: "ĺ",
    laemptyv: "⦴",
    lagran: "ℒ",
    Lambda: "Λ",
    lambda: "λ",
    lang: "⟨",
    Lang: "⟪",
    langd: "⦑",
    langle: "⟨",
    lap: "⪅",
    Laplacetrf: "ℒ",
    laquo: "«",
    larrb: "⇤",
    larrbfs: "⤟",
    larr: "←",
    Larr: "↞",
    lArr: "⇐",
    larrfs: "⤝",
    larrhk: "↩",
    larrlp: "↫",
    larrpl: "⤹",
    larrsim: "⥳",
    larrtl: "↢",
    latail: "⤙",
    lAtail: "⤛",
    lat: "⪫",
    late: "⪭",
    lates: "⪭︀",
    lbarr: "⤌",
    lBarr: "⤎",
    lbbrk: "❲",
    lbrace: "{",
    lbrack: "[",
    lbrke: "⦋",
    lbrksld: "⦏",
    lbrkslu: "⦍",
    Lcaron: "Ľ",
    lcaron: "ľ",
    Lcedil: "Ļ",
    lcedil: "ļ",
    lceil: "⌈",
    lcub: "{",
    Lcy: "Л",
    lcy: "л",
    ldca: "⤶",
    ldquo: "“",
    ldquor: "„",
    ldrdhar: "⥧",
    ldrushar: "⥋",
    ldsh: "↲",
    le: "≤",
    lE: "≦",
    LeftAngleBracket: "⟨",
    LeftArrowBar: "⇤",
    leftarrow: "←",
    LeftArrow: "←",
    Leftarrow: "⇐",
    LeftArrowRightArrow: "⇆",
    leftarrowtail: "↢",
    LeftCeiling: "⌈",
    LeftDoubleBracket: "⟦",
    LeftDownTeeVector: "⥡",
    LeftDownVectorBar: "⥙",
    LeftDownVector: "⇃",
    LeftFloor: "⌊",
    leftharpoondown: "↽",
    leftharpoonup: "↼",
    leftleftarrows: "⇇",
    leftrightarrow: "↔",
    LeftRightArrow: "↔",
    Leftrightarrow: "⇔",
    leftrightarrows: "⇆",
    leftrightharpoons: "⇋",
    leftrightsquigarrow: "↭",
    LeftRightVector: "⥎",
    LeftTeeArrow: "↤",
    LeftTee: "⊣",
    LeftTeeVector: "⥚",
    leftthreetimes: "⋋",
    LeftTriangleBar: "⧏",
    LeftTriangle: "⊲",
    LeftTriangleEqual: "⊴",
    LeftUpDownVector: "⥑",
    LeftUpTeeVector: "⥠",
    LeftUpVectorBar: "⥘",
    LeftUpVector: "↿",
    LeftVectorBar: "⥒",
    LeftVector: "↼",
    lEg: "⪋",
    leg: "⋚",
    leq: "≤",
    leqq: "≦",
    leqslant: "⩽",
    lescc: "⪨",
    les: "⩽",
    lesdot: "⩿",
    lesdoto: "⪁",
    lesdotor: "⪃",
    lesg: "⋚︀",
    lesges: "⪓",
    lessapprox: "⪅",
    lessdot: "⋖",
    lesseqgtr: "⋚",
    lesseqqgtr: "⪋",
    LessEqualGreater: "⋚",
    LessFullEqual: "≦",
    LessGreater: "≶",
    lessgtr: "≶",
    LessLess: "⪡",
    lesssim: "≲",
    LessSlantEqual: "⩽",
    LessTilde: "≲",
    lfisht: "⥼",
    lfloor: "⌊",
    Lfr: "𝔏",
    lfr: "𝔩",
    lg: "≶",
    lgE: "⪑",
    lHar: "⥢",
    lhard: "↽",
    lharu: "↼",
    lharul: "⥪",
    lhblk: "▄",
    LJcy: "Љ",
    ljcy: "љ",
    llarr: "⇇",
    ll: "≪",
    Ll: "⋘",
    llcorner: "⌞",
    Lleftarrow: "⇚",
    llhard: "⥫",
    lltri: "◺",
    Lmidot: "Ŀ",
    lmidot: "ŀ",
    lmoustache: "⎰",
    lmoust: "⎰",
    lnap: "⪉",
    lnapprox: "⪉",
    lne: "⪇",
    lnE: "≨",
    lneq: "⪇",
    lneqq: "≨",
    lnsim: "⋦",
    loang: "⟬",
    loarr: "⇽",
    lobrk: "⟦",
    longleftarrow: "⟵",
    LongLeftArrow: "⟵",
    Longleftarrow: "⟸",
    longleftrightarrow: "⟷",
    LongLeftRightArrow: "⟷",
    Longleftrightarrow: "⟺",
    longmapsto: "⟼",
    longrightarrow: "⟶",
    LongRightArrow: "⟶",
    Longrightarrow: "⟹",
    looparrowleft: "↫",
    looparrowright: "↬",
    lopar: "⦅",
    Lopf: "𝕃",
    lopf: "𝕝",
    loplus: "⨭",
    lotimes: "⨴",
    lowast: "∗",
    lowbar: "_",
    LowerLeftArrow: "↙",
    LowerRightArrow: "↘",
    loz: "◊",
    lozenge: "◊",
    lozf: "⧫",
    lpar: "(",
    lparlt: "⦓",
    lrarr: "⇆",
    lrcorner: "⌟",
    lrhar: "⇋",
    lrhard: "⥭",
    lrm: "‎",
    lrtri: "⊿",
    lsaquo: "‹",
    lscr: "𝓁",
    Lscr: "ℒ",
    lsh: "↰",
    Lsh: "↰",
    lsim: "≲",
    lsime: "⪍",
    lsimg: "⪏",
    lsqb: "[",
    lsquo: "‘",
    lsquor: "‚",
    Lstrok: "Ł",
    lstrok: "ł",
    ltcc: "⪦",
    ltcir: "⩹",
    lt: "<",
    LT: "<",
    Lt: "≪",
    ltdot: "⋖",
    lthree: "⋋",
    ltimes: "⋉",
    ltlarr: "⥶",
    ltquest: "⩻",
    ltri: "◃",
    ltrie: "⊴",
    ltrif: "◂",
    ltrPar: "⦖",
    lurdshar: "⥊",
    luruhar: "⥦",
    lvertneqq: "≨︀",
    lvnE: "≨︀",
    macr: "¯",
    male: "♂",
    malt: "✠",
    maltese: "✠",
    Map: "⤅",
    map: "↦",
    mapsto: "↦",
    mapstodown: "↧",
    mapstoleft: "↤",
    mapstoup: "↥",
    marker: "▮",
    mcomma: "⨩",
    Mcy: "М",
    mcy: "м",
    mdash: "—",
    mDDot: "∺",
    measuredangle: "∡",
    MediumSpace: " ",
    Mellintrf: "ℳ",
    Mfr: "𝔐",
    mfr: "𝔪",
    mho: "℧",
    micro: "µ",
    midast: "*",
    midcir: "⫰",
    mid: "∣",
    middot: "·",
    minusb: "⊟",
    minus: "−",
    minusd: "∸",
    minusdu: "⨪",
    MinusPlus: "∓",
    mlcp: "⫛",
    mldr: "…",
    mnplus: "∓",
    models: "⊧",
    Mopf: "𝕄",
    mopf: "𝕞",
    mp: "∓",
    mscr: "𝓂",
    Mscr: "ℳ",
    mstpos: "∾",
    Mu: "Μ",
    mu: "μ",
    multimap: "⊸",
    mumap: "⊸",
    nabla: "∇",
    Nacute: "Ń",
    nacute: "ń",
    nang: "∠⃒",
    nap: "≉",
    napE: "⩰̸",
    napid: "≋̸",
    napos: "ŉ",
    napprox: "≉",
    natural: "♮",
    naturals: "ℕ",
    natur: "♮",
    nbsp: " ",
    nbump: "≎̸",
    nbumpe: "≏̸",
    ncap: "⩃",
    Ncaron: "Ň",
    ncaron: "ň",
    Ncedil: "Ņ",
    ncedil: "ņ",
    ncong: "≇",
    ncongdot: "⩭̸",
    ncup: "⩂",
    Ncy: "Н",
    ncy: "н",
    ndash: "–",
    nearhk: "⤤",
    nearr: "↗",
    neArr: "⇗",
    nearrow: "↗",
    ne: "≠",
    nedot: "≐̸",
    NegativeMediumSpace: "​",
    NegativeThickSpace: "​",
    NegativeThinSpace: "​",
    NegativeVeryThinSpace: "​",
    nequiv: "≢",
    nesear: "⤨",
    nesim: "≂̸",
    NestedGreaterGreater: "≫",
    NestedLessLess: "≪",
    NewLine: `
`,
    nexist: "∄",
    nexists: "∄",
    Nfr: "𝔑",
    nfr: "𝔫",
    ngE: "≧̸",
    nge: "≱",
    ngeq: "≱",
    ngeqq: "≧̸",
    ngeqslant: "⩾̸",
    nges: "⩾̸",
    nGg: "⋙̸",
    ngsim: "≵",
    nGt: "≫⃒",
    ngt: "≯",
    ngtr: "≯",
    nGtv: "≫̸",
    nharr: "↮",
    nhArr: "⇎",
    nhpar: "⫲",
    ni: "∋",
    nis: "⋼",
    nisd: "⋺",
    niv: "∋",
    NJcy: "Њ",
    njcy: "њ",
    nlarr: "↚",
    nlArr: "⇍",
    nldr: "‥",
    nlE: "≦̸",
    nle: "≰",
    nleftarrow: "↚",
    nLeftarrow: "⇍",
    nleftrightarrow: "↮",
    nLeftrightarrow: "⇎",
    nleq: "≰",
    nleqq: "≦̸",
    nleqslant: "⩽̸",
    nles: "⩽̸",
    nless: "≮",
    nLl: "⋘̸",
    nlsim: "≴",
    nLt: "≪⃒",
    nlt: "≮",
    nltri: "⋪",
    nltrie: "⋬",
    nLtv: "≪̸",
    nmid: "∤",
    NoBreak: "⁠",
    NonBreakingSpace: " ",
    nopf: "𝕟",
    Nopf: "ℕ",
    Not: "⫬",
    not: "¬",
    NotCongruent: "≢",
    NotCupCap: "≭",
    NotDoubleVerticalBar: "∦",
    NotElement: "∉",
    NotEqual: "≠",
    NotEqualTilde: "≂̸",
    NotExists: "∄",
    NotGreater: "≯",
    NotGreaterEqual: "≱",
    NotGreaterFullEqual: "≧̸",
    NotGreaterGreater: "≫̸",
    NotGreaterLess: "≹",
    NotGreaterSlantEqual: "⩾̸",
    NotGreaterTilde: "≵",
    NotHumpDownHump: "≎̸",
    NotHumpEqual: "≏̸",
    notin: "∉",
    notindot: "⋵̸",
    notinE: "⋹̸",
    notinva: "∉",
    notinvb: "⋷",
    notinvc: "⋶",
    NotLeftTriangleBar: "⧏̸",
    NotLeftTriangle: "⋪",
    NotLeftTriangleEqual: "⋬",
    NotLess: "≮",
    NotLessEqual: "≰",
    NotLessGreater: "≸",
    NotLessLess: "≪̸",
    NotLessSlantEqual: "⩽̸",
    NotLessTilde: "≴",
    NotNestedGreaterGreater: "⪢̸",
    NotNestedLessLess: "⪡̸",
    notni: "∌",
    notniva: "∌",
    notnivb: "⋾",
    notnivc: "⋽",
    NotPrecedes: "⊀",
    NotPrecedesEqual: "⪯̸",
    NotPrecedesSlantEqual: "⋠",
    NotReverseElement: "∌",
    NotRightTriangleBar: "⧐̸",
    NotRightTriangle: "⋫",
    NotRightTriangleEqual: "⋭",
    NotSquareSubset: "⊏̸",
    NotSquareSubsetEqual: "⋢",
    NotSquareSuperset: "⊐̸",
    NotSquareSupersetEqual: "⋣",
    NotSubset: "⊂⃒",
    NotSubsetEqual: "⊈",
    NotSucceeds: "⊁",
    NotSucceedsEqual: "⪰̸",
    NotSucceedsSlantEqual: "⋡",
    NotSucceedsTilde: "≿̸",
    NotSuperset: "⊃⃒",
    NotSupersetEqual: "⊉",
    NotTilde: "≁",
    NotTildeEqual: "≄",
    NotTildeFullEqual: "≇",
    NotTildeTilde: "≉",
    NotVerticalBar: "∤",
    nparallel: "∦",
    npar: "∦",
    nparsl: "⫽⃥",
    npart: "∂̸",
    npolint: "⨔",
    npr: "⊀",
    nprcue: "⋠",
    nprec: "⊀",
    npreceq: "⪯̸",
    npre: "⪯̸",
    nrarrc: "⤳̸",
    nrarr: "↛",
    nrArr: "⇏",
    nrarrw: "↝̸",
    nrightarrow: "↛",
    nRightarrow: "⇏",
    nrtri: "⋫",
    nrtrie: "⋭",
    nsc: "⊁",
    nsccue: "⋡",
    nsce: "⪰̸",
    Nscr: "𝒩",
    nscr: "𝓃",
    nshortmid: "∤",
    nshortparallel: "∦",
    nsim: "≁",
    nsime: "≄",
    nsimeq: "≄",
    nsmid: "∤",
    nspar: "∦",
    nsqsube: "⋢",
    nsqsupe: "⋣",
    nsub: "⊄",
    nsubE: "⫅̸",
    nsube: "⊈",
    nsubset: "⊂⃒",
    nsubseteq: "⊈",
    nsubseteqq: "⫅̸",
    nsucc: "⊁",
    nsucceq: "⪰̸",
    nsup: "⊅",
    nsupE: "⫆̸",
    nsupe: "⊉",
    nsupset: "⊃⃒",
    nsupseteq: "⊉",
    nsupseteqq: "⫆̸",
    ntgl: "≹",
    Ntilde: "Ñ",
    ntilde: "ñ",
    ntlg: "≸",
    ntriangleleft: "⋪",
    ntrianglelefteq: "⋬",
    ntriangleright: "⋫",
    ntrianglerighteq: "⋭",
    Nu: "Ν",
    nu: "ν",
    num: "#",
    numero: "№",
    numsp: " ",
    nvap: "≍⃒",
    nvdash: "⊬",
    nvDash: "⊭",
    nVdash: "⊮",
    nVDash: "⊯",
    nvge: "≥⃒",
    nvgt: ">⃒",
    nvHarr: "⤄",
    nvinfin: "⧞",
    nvlArr: "⤂",
    nvle: "≤⃒",
    nvlt: "<⃒",
    nvltrie: "⊴⃒",
    nvrArr: "⤃",
    nvrtrie: "⊵⃒",
    nvsim: "∼⃒",
    nwarhk: "⤣",
    nwarr: "↖",
    nwArr: "⇖",
    nwarrow: "↖",
    nwnear: "⤧",
    Oacute: "Ó",
    oacute: "ó",
    oast: "⊛",
    Ocirc: "Ô",
    ocirc: "ô",
    ocir: "⊚",
    Ocy: "О",
    ocy: "о",
    odash: "⊝",
    Odblac: "Ő",
    odblac: "ő",
    odiv: "⨸",
    odot: "⊙",
    odsold: "⦼",
    OElig: "Œ",
    oelig: "œ",
    ofcir: "⦿",
    Ofr: "𝔒",
    ofr: "𝔬",
    ogon: "˛",
    Ograve: "Ò",
    ograve: "ò",
    ogt: "⧁",
    ohbar: "⦵",
    ohm: "Ω",
    oint: "∮",
    olarr: "↺",
    olcir: "⦾",
    olcross: "⦻",
    oline: "‾",
    olt: "⧀",
    Omacr: "Ō",
    omacr: "ō",
    Omega: "Ω",
    omega: "ω",
    Omicron: "Ο",
    omicron: "ο",
    omid: "⦶",
    ominus: "⊖",
    Oopf: "𝕆",
    oopf: "𝕠",
    opar: "⦷",
    OpenCurlyDoubleQuote: "“",
    OpenCurlyQuote: "‘",
    operp: "⦹",
    oplus: "⊕",
    orarr: "↻",
    Or: "⩔",
    or: "∨",
    ord: "⩝",
    order: "ℴ",
    orderof: "ℴ",
    ordf: "ª",
    ordm: "º",
    origof: "⊶",
    oror: "⩖",
    orslope: "⩗",
    orv: "⩛",
    oS: "Ⓢ",
    Oscr: "𝒪",
    oscr: "ℴ",
    Oslash: "Ø",
    oslash: "ø",
    osol: "⊘",
    Otilde: "Õ",
    otilde: "õ",
    otimesas: "⨶",
    Otimes: "⨷",
    otimes: "⊗",
    Ouml: "Ö",
    ouml: "ö",
    ovbar: "⌽",
    OverBar: "‾",
    OverBrace: "⏞",
    OverBracket: "⎴",
    OverParenthesis: "⏜",
    para: "¶",
    parallel: "∥",
    par: "∥",
    parsim: "⫳",
    parsl: "⫽",
    part: "∂",
    PartialD: "∂",
    Pcy: "П",
    pcy: "п",
    percnt: "%",
    period: ".",
    permil: "‰",
    perp: "⊥",
    pertenk: "‱",
    Pfr: "𝔓",
    pfr: "𝔭",
    Phi: "Φ",
    phi: "φ",
    phiv: "ϕ",
    phmmat: "ℳ",
    phone: "☎",
    Pi: "Π",
    pi: "π",
    pitchfork: "⋔",
    piv: "ϖ",
    planck: "ℏ",
    planckh: "ℎ",
    plankv: "ℏ",
    plusacir: "⨣",
    plusb: "⊞",
    pluscir: "⨢",
    plus: "+",
    plusdo: "∔",
    plusdu: "⨥",
    pluse: "⩲",
    PlusMinus: "±",
    plusmn: "±",
    plussim: "⨦",
    plustwo: "⨧",
    pm: "±",
    Poincareplane: "ℌ",
    pointint: "⨕",
    popf: "𝕡",
    Popf: "ℙ",
    pound: "£",
    prap: "⪷",
    Pr: "⪻",
    pr: "≺",
    prcue: "≼",
    precapprox: "⪷",
    prec: "≺",
    preccurlyeq: "≼",
    Precedes: "≺",
    PrecedesEqual: "⪯",
    PrecedesSlantEqual: "≼",
    PrecedesTilde: "≾",
    preceq: "⪯",
    precnapprox: "⪹",
    precneqq: "⪵",
    precnsim: "⋨",
    pre: "⪯",
    prE: "⪳",
    precsim: "≾",
    prime: "′",
    Prime: "″",
    primes: "ℙ",
    prnap: "⪹",
    prnE: "⪵",
    prnsim: "⋨",
    prod: "∏",
    Product: "∏",
    profalar: "⌮",
    profline: "⌒",
    profsurf: "⌓",
    prop: "∝",
    Proportional: "∝",
    Proportion: "∷",
    propto: "∝",
    prsim: "≾",
    prurel: "⊰",
    Pscr: "𝒫",
    pscr: "𝓅",
    Psi: "Ψ",
    psi: "ψ",
    puncsp: " ",
    Qfr: "𝔔",
    qfr: "𝔮",
    qint: "⨌",
    qopf: "𝕢",
    Qopf: "ℚ",
    qprime: "⁗",
    Qscr: "𝒬",
    qscr: "𝓆",
    quaternions: "ℍ",
    quatint: "⨖",
    quest: "?",
    questeq: "≟",
    quot: '"',
    QUOT: '"',
    rAarr: "⇛",
    race: "∽̱",
    Racute: "Ŕ",
    racute: "ŕ",
    radic: "√",
    raemptyv: "⦳",
    rang: "⟩",
    Rang: "⟫",
    rangd: "⦒",
    range: "⦥",
    rangle: "⟩",
    raquo: "»",
    rarrap: "⥵",
    rarrb: "⇥",
    rarrbfs: "⤠",
    rarrc: "⤳",
    rarr: "→",
    Rarr: "↠",
    rArr: "⇒",
    rarrfs: "⤞",
    rarrhk: "↪",
    rarrlp: "↬",
    rarrpl: "⥅",
    rarrsim: "⥴",
    Rarrtl: "⤖",
    rarrtl: "↣",
    rarrw: "↝",
    ratail: "⤚",
    rAtail: "⤜",
    ratio: "∶",
    rationals: "ℚ",
    rbarr: "⤍",
    rBarr: "⤏",
    RBarr: "⤐",
    rbbrk: "❳",
    rbrace: "}",
    rbrack: "]",
    rbrke: "⦌",
    rbrksld: "⦎",
    rbrkslu: "⦐",
    Rcaron: "Ř",
    rcaron: "ř",
    Rcedil: "Ŗ",
    rcedil: "ŗ",
    rceil: "⌉",
    rcub: "}",
    Rcy: "Р",
    rcy: "р",
    rdca: "⤷",
    rdldhar: "⥩",
    rdquo: "”",
    rdquor: "”",
    rdsh: "↳",
    real: "ℜ",
    realine: "ℛ",
    realpart: "ℜ",
    reals: "ℝ",
    Re: "ℜ",
    rect: "▭",
    reg: "®",
    REG: "®",
    ReverseElement: "∋",
    ReverseEquilibrium: "⇋",
    ReverseUpEquilibrium: "⥯",
    rfisht: "⥽",
    rfloor: "⌋",
    rfr: "𝔯",
    Rfr: "ℜ",
    rHar: "⥤",
    rhard: "⇁",
    rharu: "⇀",
    rharul: "⥬",
    Rho: "Ρ",
    rho: "ρ",
    rhov: "ϱ",
    RightAngleBracket: "⟩",
    RightArrowBar: "⇥",
    rightarrow: "→",
    RightArrow: "→",
    Rightarrow: "⇒",
    RightArrowLeftArrow: "⇄",
    rightarrowtail: "↣",
    RightCeiling: "⌉",
    RightDoubleBracket: "⟧",
    RightDownTeeVector: "⥝",
    RightDownVectorBar: "⥕",
    RightDownVector: "⇂",
    RightFloor: "⌋",
    rightharpoondown: "⇁",
    rightharpoonup: "⇀",
    rightleftarrows: "⇄",
    rightleftharpoons: "⇌",
    rightrightarrows: "⇉",
    rightsquigarrow: "↝",
    RightTeeArrow: "↦",
    RightTee: "⊢",
    RightTeeVector: "⥛",
    rightthreetimes: "⋌",
    RightTriangleBar: "⧐",
    RightTriangle: "⊳",
    RightTriangleEqual: "⊵",
    RightUpDownVector: "⥏",
    RightUpTeeVector: "⥜",
    RightUpVectorBar: "⥔",
    RightUpVector: "↾",
    RightVectorBar: "⥓",
    RightVector: "⇀",
    ring: "˚",
    risingdotseq: "≓",
    rlarr: "⇄",
    rlhar: "⇌",
    rlm: "‏",
    rmoustache: "⎱",
    rmoust: "⎱",
    rnmid: "⫮",
    roang: "⟭",
    roarr: "⇾",
    robrk: "⟧",
    ropar: "⦆",
    ropf: "𝕣",
    Ropf: "ℝ",
    roplus: "⨮",
    rotimes: "⨵",
    RoundImplies: "⥰",
    rpar: ")",
    rpargt: "⦔",
    rppolint: "⨒",
    rrarr: "⇉",
    Rrightarrow: "⇛",
    rsaquo: "›",
    rscr: "𝓇",
    Rscr: "ℛ",
    rsh: "↱",
    Rsh: "↱",
    rsqb: "]",
    rsquo: "’",
    rsquor: "’",
    rthree: "⋌",
    rtimes: "⋊",
    rtri: "▹",
    rtrie: "⊵",
    rtrif: "▸",
    rtriltri: "⧎",
    RuleDelayed: "⧴",
    ruluhar: "⥨",
    rx: "℞",
    Sacute: "Ś",
    sacute: "ś",
    sbquo: "‚",
    scap: "⪸",
    Scaron: "Š",
    scaron: "š",
    Sc: "⪼",
    sc: "≻",
    sccue: "≽",
    sce: "⪰",
    scE: "⪴",
    Scedil: "Ş",
    scedil: "ş",
    Scirc: "Ŝ",
    scirc: "ŝ",
    scnap: "⪺",
    scnE: "⪶",
    scnsim: "⋩",
    scpolint: "⨓",
    scsim: "≿",
    Scy: "С",
    scy: "с",
    sdotb: "⊡",
    sdot: "⋅",
    sdote: "⩦",
    searhk: "⤥",
    searr: "↘",
    seArr: "⇘",
    searrow: "↘",
    sect: "§",
    semi: ";",
    seswar: "⤩",
    setminus: "∖",
    setmn: "∖",
    sext: "✶",
    Sfr: "𝔖",
    sfr: "𝔰",
    sfrown: "⌢",
    sharp: "♯",
    SHCHcy: "Щ",
    shchcy: "щ",
    SHcy: "Ш",
    shcy: "ш",
    ShortDownArrow: "↓",
    ShortLeftArrow: "←",
    shortmid: "∣",
    shortparallel: "∥",
    ShortRightArrow: "→",
    ShortUpArrow: "↑",
    shy: "­",
    Sigma: "Σ",
    sigma: "σ",
    sigmaf: "ς",
    sigmav: "ς",
    sim: "∼",
    simdot: "⩪",
    sime: "≃",
    simeq: "≃",
    simg: "⪞",
    simgE: "⪠",
    siml: "⪝",
    simlE: "⪟",
    simne: "≆",
    simplus: "⨤",
    simrarr: "⥲",
    slarr: "←",
    SmallCircle: "∘",
    smallsetminus: "∖",
    smashp: "⨳",
    smeparsl: "⧤",
    smid: "∣",
    smile: "⌣",
    smt: "⪪",
    smte: "⪬",
    smtes: "⪬︀",
    SOFTcy: "Ь",
    softcy: "ь",
    solbar: "⌿",
    solb: "⧄",
    sol: "/",
    Sopf: "𝕊",
    sopf: "𝕤",
    spades: "♠",
    spadesuit: "♠",
    spar: "∥",
    sqcap: "⊓",
    sqcaps: "⊓︀",
    sqcup: "⊔",
    sqcups: "⊔︀",
    Sqrt: "√",
    sqsub: "⊏",
    sqsube: "⊑",
    sqsubset: "⊏",
    sqsubseteq: "⊑",
    sqsup: "⊐",
    sqsupe: "⊒",
    sqsupset: "⊐",
    sqsupseteq: "⊒",
    square: "□",
    Square: "□",
    SquareIntersection: "⊓",
    SquareSubset: "⊏",
    SquareSubsetEqual: "⊑",
    SquareSuperset: "⊐",
    SquareSupersetEqual: "⊒",
    SquareUnion: "⊔",
    squarf: "▪",
    squ: "□",
    squf: "▪",
    srarr: "→",
    Sscr: "𝒮",
    sscr: "𝓈",
    ssetmn: "∖",
    ssmile: "⌣",
    sstarf: "⋆",
    Star: "⋆",
    star: "☆",
    starf: "★",
    straightepsilon: "ϵ",
    straightphi: "ϕ",
    strns: "¯",
    sub: "⊂",
    Sub: "⋐",
    subdot: "⪽",
    subE: "⫅",
    sube: "⊆",
    subedot: "⫃",
    submult: "⫁",
    subnE: "⫋",
    subne: "⊊",
    subplus: "⪿",
    subrarr: "⥹",
    subset: "⊂",
    Subset: "⋐",
    subseteq: "⊆",
    subseteqq: "⫅",
    SubsetEqual: "⊆",
    subsetneq: "⊊",
    subsetneqq: "⫋",
    subsim: "⫇",
    subsub: "⫕",
    subsup: "⫓",
    succapprox: "⪸",
    succ: "≻",
    succcurlyeq: "≽",
    Succeeds: "≻",
    SucceedsEqual: "⪰",
    SucceedsSlantEqual: "≽",
    SucceedsTilde: "≿",
    succeq: "⪰",
    succnapprox: "⪺",
    succneqq: "⪶",
    succnsim: "⋩",
    succsim: "≿",
    SuchThat: "∋",
    sum: "∑",
    Sum: "∑",
    sung: "♪",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    sup: "⊃",
    Sup: "⋑",
    supdot: "⪾",
    supdsub: "⫘",
    supE: "⫆",
    supe: "⊇",
    supedot: "⫄",
    Superset: "⊃",
    SupersetEqual: "⊇",
    suphsol: "⟉",
    suphsub: "⫗",
    suplarr: "⥻",
    supmult: "⫂",
    supnE: "⫌",
    supne: "⊋",
    supplus: "⫀",
    supset: "⊃",
    Supset: "⋑",
    supseteq: "⊇",
    supseteqq: "⫆",
    supsetneq: "⊋",
    supsetneqq: "⫌",
    supsim: "⫈",
    supsub: "⫔",
    supsup: "⫖",
    swarhk: "⤦",
    swarr: "↙",
    swArr: "⇙",
    swarrow: "↙",
    swnwar: "⤪",
    szlig: "ß",
    Tab: "	",
    target: "⌖",
    Tau: "Τ",
    tau: "τ",
    tbrk: "⎴",
    Tcaron: "Ť",
    tcaron: "ť",
    Tcedil: "Ţ",
    tcedil: "ţ",
    Tcy: "Т",
    tcy: "т",
    tdot: "⃛",
    telrec: "⌕",
    Tfr: "𝔗",
    tfr: "𝔱",
    there4: "∴",
    therefore: "∴",
    Therefore: "∴",
    Theta: "Θ",
    theta: "θ",
    thetasym: "ϑ",
    thetav: "ϑ",
    thickapprox: "≈",
    thicksim: "∼",
    ThickSpace: "  ",
    ThinSpace: " ",
    thinsp: " ",
    thkap: "≈",
    thksim: "∼",
    THORN: "Þ",
    thorn: "þ",
    tilde: "˜",
    Tilde: "∼",
    TildeEqual: "≃",
    TildeFullEqual: "≅",
    TildeTilde: "≈",
    timesbar: "⨱",
    timesb: "⊠",
    times: "×",
    timesd: "⨰",
    tint: "∭",
    toea: "⤨",
    topbot: "⌶",
    topcir: "⫱",
    top: "⊤",
    Topf: "𝕋",
    topf: "𝕥",
    topfork: "⫚",
    tosa: "⤩",
    tprime: "‴",
    trade: "™",
    TRADE: "™",
    triangle: "▵",
    triangledown: "▿",
    triangleleft: "◃",
    trianglelefteq: "⊴",
    triangleq: "≜",
    triangleright: "▹",
    trianglerighteq: "⊵",
    tridot: "◬",
    trie: "≜",
    triminus: "⨺",
    TripleDot: "⃛",
    triplus: "⨹",
    trisb: "⧍",
    tritime: "⨻",
    trpezium: "⏢",
    Tscr: "𝒯",
    tscr: "𝓉",
    TScy: "Ц",
    tscy: "ц",
    TSHcy: "Ћ",
    tshcy: "ћ",
    Tstrok: "Ŧ",
    tstrok: "ŧ",
    twixt: "≬",
    twoheadleftarrow: "↞",
    twoheadrightarrow: "↠",
    Uacute: "Ú",
    uacute: "ú",
    uarr: "↑",
    Uarr: "↟",
    uArr: "⇑",
    Uarrocir: "⥉",
    Ubrcy: "Ў",
    ubrcy: "ў",
    Ubreve: "Ŭ",
    ubreve: "ŭ",
    Ucirc: "Û",
    ucirc: "û",
    Ucy: "У",
    ucy: "у",
    udarr: "⇅",
    Udblac: "Ű",
    udblac: "ű",
    udhar: "⥮",
    ufisht: "⥾",
    Ufr: "𝔘",
    ufr: "𝔲",
    Ugrave: "Ù",
    ugrave: "ù",
    uHar: "⥣",
    uharl: "↿",
    uharr: "↾",
    uhblk: "▀",
    ulcorn: "⌜",
    ulcorner: "⌜",
    ulcrop: "⌏",
    ultri: "◸",
    Umacr: "Ū",
    umacr: "ū",
    uml: "¨",
    UnderBar: "_",
    UnderBrace: "⏟",
    UnderBracket: "⎵",
    UnderParenthesis: "⏝",
    Union: "⋃",
    UnionPlus: "⊎",
    Uogon: "Ų",
    uogon: "ų",
    Uopf: "𝕌",
    uopf: "𝕦",
    UpArrowBar: "⤒",
    uparrow: "↑",
    UpArrow: "↑",
    Uparrow: "⇑",
    UpArrowDownArrow: "⇅",
    updownarrow: "↕",
    UpDownArrow: "↕",
    Updownarrow: "⇕",
    UpEquilibrium: "⥮",
    upharpoonleft: "↿",
    upharpoonright: "↾",
    uplus: "⊎",
    UpperLeftArrow: "↖",
    UpperRightArrow: "↗",
    upsi: "υ",
    Upsi: "ϒ",
    upsih: "ϒ",
    Upsilon: "Υ",
    upsilon: "υ",
    UpTeeArrow: "↥",
    UpTee: "⊥",
    upuparrows: "⇈",
    urcorn: "⌝",
    urcorner: "⌝",
    urcrop: "⌎",
    Uring: "Ů",
    uring: "ů",
    urtri: "◹",
    Uscr: "𝒰",
    uscr: "𝓊",
    utdot: "⋰",
    Utilde: "Ũ",
    utilde: "ũ",
    utri: "▵",
    utrif: "▴",
    uuarr: "⇈",
    Uuml: "Ü",
    uuml: "ü",
    uwangle: "⦧",
    vangrt: "⦜",
    varepsilon: "ϵ",
    varkappa: "ϰ",
    varnothing: "∅",
    varphi: "ϕ",
    varpi: "ϖ",
    varpropto: "∝",
    varr: "↕",
    vArr: "⇕",
    varrho: "ϱ",
    varsigma: "ς",
    varsubsetneq: "⊊︀",
    varsubsetneqq: "⫋︀",
    varsupsetneq: "⊋︀",
    varsupsetneqq: "⫌︀",
    vartheta: "ϑ",
    vartriangleleft: "⊲",
    vartriangleright: "⊳",
    vBar: "⫨",
    Vbar: "⫫",
    vBarv: "⫩",
    Vcy: "В",
    vcy: "в",
    vdash: "⊢",
    vDash: "⊨",
    Vdash: "⊩",
    VDash: "⊫",
    Vdashl: "⫦",
    veebar: "⊻",
    vee: "∨",
    Vee: "⋁",
    veeeq: "≚",
    vellip: "⋮",
    verbar: "|",
    Verbar: "‖",
    vert: "|",
    Vert: "‖",
    VerticalBar: "∣",
    VerticalLine: "|",
    VerticalSeparator: "❘",
    VerticalTilde: "≀",
    VeryThinSpace: " ",
    Vfr: "𝔙",
    vfr: "𝔳",
    vltri: "⊲",
    vnsub: "⊂⃒",
    vnsup: "⊃⃒",
    Vopf: "𝕍",
    vopf: "𝕧",
    vprop: "∝",
    vrtri: "⊳",
    Vscr: "𝒱",
    vscr: "𝓋",
    vsubnE: "⫋︀",
    vsubne: "⊊︀",
    vsupnE: "⫌︀",
    vsupne: "⊋︀",
    Vvdash: "⊪",
    vzigzag: "⦚",
    Wcirc: "Ŵ",
    wcirc: "ŵ",
    wedbar: "⩟",
    wedge: "∧",
    Wedge: "⋀",
    wedgeq: "≙",
    weierp: "℘",
    Wfr: "𝔚",
    wfr: "𝔴",
    Wopf: "𝕎",
    wopf: "𝕨",
    wp: "℘",
    wr: "≀",
    wreath: "≀",
    Wscr: "𝒲",
    wscr: "𝓌",
    xcap: "⋂",
    xcirc: "◯",
    xcup: "⋃",
    xdtri: "▽",
    Xfr: "𝔛",
    xfr: "𝔵",
    xharr: "⟷",
    xhArr: "⟺",
    Xi: "Ξ",
    xi: "ξ",
    xlarr: "⟵",
    xlArr: "⟸",
    xmap: "⟼",
    xnis: "⋻",
    xodot: "⨀",
    Xopf: "𝕏",
    xopf: "𝕩",
    xoplus: "⨁",
    xotime: "⨂",
    xrarr: "⟶",
    xrArr: "⟹",
    Xscr: "𝒳",
    xscr: "𝓍",
    xsqcup: "⨆",
    xuplus: "⨄",
    xutri: "△",
    xvee: "⋁",
    xwedge: "⋀",
    Yacute: "Ý",
    yacute: "ý",
    YAcy: "Я",
    yacy: "я",
    Ycirc: "Ŷ",
    ycirc: "ŷ",
    Ycy: "Ы",
    ycy: "ы",
    yen: "¥",
    Yfr: "𝔜",
    yfr: "𝔶",
    YIcy: "Ї",
    yicy: "ї",
    Yopf: "𝕐",
    yopf: "𝕪",
    Yscr: "𝒴",
    yscr: "𝓎",
    YUcy: "Ю",
    yucy: "ю",
    yuml: "ÿ",
    Yuml: "Ÿ",
    Zacute: "Ź",
    zacute: "ź",
    Zcaron: "Ž",
    zcaron: "ž",
    Zcy: "З",
    zcy: "з",
    Zdot: "Ż",
    zdot: "ż",
    zeetrf: "ℨ",
    ZeroWidthSpace: "​",
    Zeta: "Ζ",
    zeta: "ζ",
    zfr: "𝔷",
    Zfr: "ℨ",
    ZHcy: "Ж",
    zhcy: "ж",
    zigrarr: "⇝",
    zopf: "𝕫",
    Zopf: "ℤ",
    Zscr: "𝒵",
    zscr: "𝓏",
    zwj: "‍",
    zwnj: "‌"
  };
});
var sn = k4((Pf, ja) => {
  ja.exports = {
    Aacute: "Á",
    aacute: "á",
    Acirc: "Â",
    acirc: "â",
    acute: "´",
    AElig: "Æ",
    aelig: "æ",
    Agrave: "À",
    agrave: "à",
    amp: "&",
    AMP: "&",
    Aring: "Å",
    aring: "å",
    Atilde: "Ã",
    atilde: "ã",
    Auml: "Ä",
    auml: "ä",
    brvbar: "¦",
    Ccedil: "Ç",
    ccedil: "ç",
    cedil: "¸",
    cent: "¢",
    copy: "©",
    COPY: "©",
    curren: "¤",
    deg: "°",
    divide: "÷",
    Eacute: "É",
    eacute: "é",
    Ecirc: "Ê",
    ecirc: "ê",
    Egrave: "È",
    egrave: "è",
    ETH: "Ð",
    eth: "ð",
    Euml: "Ë",
    euml: "ë",
    frac12: "½",
    frac14: "¼",
    frac34: "¾",
    gt: ">",
    GT: ">",
    Iacute: "Í",
    iacute: "í",
    Icirc: "Î",
    icirc: "î",
    iexcl: "¡",
    Igrave: "Ì",
    igrave: "ì",
    iquest: "¿",
    Iuml: "Ï",
    iuml: "ï",
    laquo: "«",
    lt: "<",
    LT: "<",
    macr: "¯",
    micro: "µ",
    middot: "·",
    nbsp: " ",
    not: "¬",
    Ntilde: "Ñ",
    ntilde: "ñ",
    Oacute: "Ó",
    oacute: "ó",
    Ocirc: "Ô",
    ocirc: "ô",
    Ograve: "Ò",
    ograve: "ò",
    ordf: "ª",
    ordm: "º",
    Oslash: "Ø",
    oslash: "ø",
    Otilde: "Õ",
    otilde: "õ",
    Ouml: "Ö",
    ouml: "ö",
    para: "¶",
    plusmn: "±",
    pound: "£",
    quot: '"',
    QUOT: '"',
    raquo: "»",
    reg: "®",
    REG: "®",
    sect: "§",
    shy: "­",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    szlig: "ß",
    THORN: "Þ",
    thorn: "þ",
    times: "×",
    Uacute: "Ú",
    uacute: "ú",
    Ucirc: "Û",
    ucirc: "û",
    Ugrave: "Ù",
    ugrave: "ù",
    uml: "¨",
    Uuml: "Ü",
    uuml: "ü",
    Yacute: "Ý",
    yacute: "ý",
    yen: "¥",
    yuml: "ÿ"
  };
});
var bt = k4((Ff, La) => {
  La.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});
var an = k4((If, Na) => {
  Na.exports = {
    "0": 65533,
    "128": 8364,
    "130": 8218,
    "131": 402,
    "132": 8222,
    "133": 8230,
    "134": 8224,
    "135": 8225,
    "136": 710,
    "137": 8240,
    "138": 352,
    "139": 8249,
    "140": 338,
    "142": 381,
    "145": 8216,
    "146": 8217,
    "147": 8220,
    "148": 8221,
    "149": 8226,
    "150": 8211,
    "151": 8212,
    "152": 732,
    "153": 8482,
    "154": 353,
    "155": 8250,
    "156": 339,
    "158": 382,
    "159": 376
  };
});
var cn = k4((ze) => {
  "use strict";
  var Ma = ze && ze.__importDefault || function(r3) {
    return r3 && r3.__esModule ? r3 : { default: r3 };
  };
  Object.defineProperty(ze, "__esModule", { value: true });
  var ln = Ma(an()), _a = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint || function(r3) {
      var e2 = "";
      return r3 > 65535 && (r3 -= 65536, e2 += String.fromCharCode(r3 >>> 10 & 1023 | 55296), r3 = 56320 | r3 & 1023), e2 += String.fromCharCode(r3), e2;
    }
  );
  function qa(r3) {
    return r3 >= 55296 && r3 <= 57343 || r3 > 1114111 ? "�" : (r3 in ln.default && (r3 = ln.default[r3]), _a(r3));
  }
  s3(qa, "decodeCodePoint");
  ze.default = qa;
});
var Et = k4(($4) => {
  "use strict";
  var dr = $4 && $4.__importDefault || function(r3) {
    return r3 && r3.__esModule ? r3 : { default: r3 };
  };
  Object.defineProperty($4, "__esModule", { value: true });
  $4.decodeHTML = $4.decodeHTMLStrict = $4.decodeXML = void 0;
  var Tt = dr(St()), Ua = dr(sn()), Ga = dr(bt()), dn = dr(cn()), Ba = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  $4.decodeXML = un(Ga.default);
  $4.decodeHTMLStrict = un(Tt.default);
  function un(r3) {
    var e2 = fn(r3);
    return function(t3) {
      return String(t3).replace(Ba, e2);
    };
  }
  s3(un, "getStrictDecoder");
  var pn = s3(function(r3, e2) {
    return r3 < e2 ? 1 : -1;
  }, "sorter");
  $4.decodeHTML = function() {
    for (var r3 = Object.keys(Ua.default).sort(pn), e2 = Object.keys(Tt.default).sort(pn), t3 = 0, o2 = 0; t3 < e2.length; t3++)
      r3[o2] === e2[t3] ? (e2[t3] += ";?", o2++) : e2[t3] += ";";
    var n3 = new RegExp("&(?:" + e2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), i = fn(Tt.default);
    function a2(l) {
      return l.substr(-1) !== ";" && (l += ";"), i(l);
    }
    return s3(a2, "replacer"), function(l) {
      return String(l).replace(n3, a2);
    };
  }();
  function fn(r3) {
    return s3(function(t3) {
      if (t3.charAt(1) === "#") {
        var o2 = t3.charAt(2);
        return o2 === "X" || o2 === "x" ? dn.default(parseInt(t3.substr(3), 16)) : dn.default(parseInt(t3.substr(2), 10));
      }
      return r3[t3.slice(1, -1)] || t3;
    }, "replace");
  }
  s3(fn, "getReplacer");
});
var xt = k4((_4) => {
  "use strict";
  var yn = _4 && _4.__importDefault || function(r3) {
    return r3 && r3.__esModule ? r3 : { default: r3 };
  };
  Object.defineProperty(_4, "__esModule", { value: true });
  _4.escapeUTF8 = _4.escape = _4.encodeNonAsciiHTML = _4.encodeHTML = _4.encodeXML = void 0;
  var za = yn(bt()), hn = gn(za.default), mn = Sn(hn);
  _4.encodeXML = En(hn);
  var Va = yn(St()), Rt = gn(Va.default), Ha = Sn(Rt);
  _4.encodeHTML = $a(Rt, Ha);
  _4.encodeNonAsciiHTML = En(Rt);
  function gn(r3) {
    return Object.keys(r3).sort().reduce(function(e2, t3) {
      return e2[r3[t3]] = "&" + t3 + ";", e2;
    }, {});
  }
  s3(gn, "getInverseObj");
  function Sn(r3) {
    for (var e2 = [], t3 = [], o2 = 0, n3 = Object.keys(r3); o2 < n3.length; o2++) {
      var i = n3[o2];
      i.length === 1 ? e2.push("\\" + i) : t3.push(i);
    }
    e2.sort();
    for (var a2 = 0; a2 < e2.length - 1; a2++) {
      for (var l = a2; l < e2.length - 1 && e2[l].charCodeAt(1) + 1 === e2[l + 1].charCodeAt(1); )
        l += 1;
      var c = 1 + l - a2;
      c < 3 || e2.splice(a2, c, e2[a2] + "-" + e2[l]);
    }
    return t3.unshift("[" + e2.join("") + "]"), new RegExp(t3.join("|"), "g");
  }
  s3(Sn, "getInverseReplacer");
  var bn = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, Wa = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      function(r3) {
        return r3.codePointAt(0);
      }
    ) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(r3) {
        return (r3.charCodeAt(0) - 55296) * 1024 + r3.charCodeAt(1) - 56320 + 65536;
      }
    )
  );
  function pr(r3) {
    return "&#x" + (r3.length > 1 ? Wa(r3) : r3.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  s3(pr, "singleCharReplacer");
  function $a(r3, e2) {
    return function(t3) {
      return t3.replace(e2, function(o2) {
        return r3[o2];
      }).replace(bn, pr);
    };
  }
  s3($a, "getInverse");
  var Tn = new RegExp(mn.source + "|" + bn.source, "g");
  function Ya(r3) {
    return r3.replace(Tn, pr);
  }
  s3(Ya, "escape");
  _4.escape = Ya;
  function Ka(r3) {
    return r3.replace(mn, pr);
  }
  s3(Ka, "escapeUTF8");
  _4.escapeUTF8 = Ka;
  function En(r3) {
    return function(e2) {
      return e2.replace(Tn, function(t3) {
        return r3[t3] || pr(t3);
      });
    };
  }
  s3(En, "getASCIIEncoder");
});
var xn = k4((v4) => {
  "use strict";
  Object.defineProperty(v4, "__esModule", { value: true });
  v4.decodeXMLStrict = v4.decodeHTML5Strict = v4.decodeHTML4Strict = v4.decodeHTML5 = v4.decodeHTML4 = v4.decodeHTMLStrict = v4.decodeHTML = v4.decodeXML = v4.encodeHTML5 = v4.encodeHTML4 = v4.escapeUTF8 = v4.escape = v4.encodeNonAsciiHTML = v4.encodeHTML = v4.encodeXML = v4.encode = v4.decodeStrict = v4.decode = void 0;
  var ur = Et(), Rn = xt();
  function Xa(r3, e2) {
    return (!e2 || e2 <= 0 ? ur.decodeXML : ur.decodeHTML)(r3);
  }
  s3(Xa, "decode");
  v4.decode = Xa;
  function Ja(r3, e2) {
    return (!e2 || e2 <= 0 ? ur.decodeXML : ur.decodeHTMLStrict)(r3);
  }
  s3(Ja, "decodeStrict");
  v4.decodeStrict = Ja;
  function Qa(r3, e2) {
    return (!e2 || e2 <= 0 ? Rn.encodeXML : Rn.encodeHTML)(r3);
  }
  s3(Qa, "encode");
  v4.encode = Qa;
  var ue = xt();
  Object.defineProperty(v4, "encodeXML", { enumerable: true, get: s3(function() {
    return ue.encodeXML;
  }, "get") });
  Object.defineProperty(v4, "encodeHTML", { enumerable: true, get: s3(function() {
    return ue.encodeHTML;
  }, "get") });
  Object.defineProperty(v4, "encodeNonAsciiHTML", { enumerable: true, get: s3(function() {
    return ue.encodeNonAsciiHTML;
  }, "get") });
  Object.defineProperty(v4, "escape", { enumerable: true, get: s3(function() {
    return ue.escape;
  }, "get") });
  Object.defineProperty(v4, "escapeUTF8", { enumerable: true, get: s3(function() {
    return ue.escapeUTF8;
  }, "get") });
  Object.defineProperty(v4, "encodeHTML4", { enumerable: true, get: s3(function() {
    return ue.encodeHTML;
  }, "get") });
  Object.defineProperty(v4, "encodeHTML5", { enumerable: true, get: s3(function() {
    return ue.encodeHTML;
  }, "get") });
  var oe3 = Et();
  Object.defineProperty(v4, "decodeXML", { enumerable: true, get: s3(function() {
    return oe3.decodeXML;
  }, "get") });
  Object.defineProperty(v4, "decodeHTML", { enumerable: true, get: s3(function() {
    return oe3.decodeHTML;
  }, "get") });
  Object.defineProperty(v4, "decodeHTMLStrict", { enumerable: true, get: s3(function() {
    return oe3.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(v4, "decodeHTML4", { enumerable: true, get: s3(function() {
    return oe3.decodeHTML;
  }, "get") });
  Object.defineProperty(v4, "decodeHTML5", { enumerable: true, get: s3(function() {
    return oe3.decodeHTML;
  }, "get") });
  Object.defineProperty(v4, "decodeHTML4Strict", { enumerable: true, get: s3(function() {
    return oe3.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(v4, "decodeHTML5Strict", { enumerable: true, get: s3(function() {
    return oe3.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(v4, "decodeXMLStrict", { enumerable: true, get: s3(function() {
    return oe3.decodeXML;
  }, "get") });
});
var jn = k4((qf, kn) => {
  "use strict";
  function Za(r3, e2) {
    if (!(r3 instanceof e2))
      throw new TypeError("Cannot call a class as a function");
  }
  s3(Za, "_classCallCheck");
  function wn(r3, e2) {
    for (var t3 = 0; t3 < e2.length; t3++) {
      var o2 = e2[t3];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(r3, o2.key, o2);
    }
  }
  s3(wn, "_defineProperties");
  function el(r3, e2, t3) {
    return e2 && wn(r3.prototype, e2), t3 && wn(r3, t3), r3;
  }
  s3(el, "_createClass");
  function In(r3, e2) {
    var t3 = typeof Symbol < "u" && r3[Symbol.iterator] || r3["@@iterator"];
    if (!t3) {
      if (Array.isArray(r3) || (t3 = rl(r3)) || e2 && r3 && typeof r3.length == "number") {
        t3 && (r3 = t3);
        var o2 = 0, n3 = s3(function() {
        }, "F");
        return { s: n3, n: s3(function() {
          return o2 >= r3.length ? { done: true } : { done: false, value: r3[o2++] };
        }, "n"), e: s3(function(d) {
          throw d;
        }, "e"), f: n3 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var i = true, a2 = false, l;
    return { s: s3(function() {
      t3 = t3.call(r3);
    }, "s"), n: s3(function() {
      var d = t3.next();
      return i = d.done, d;
    }, "n"), e: s3(function(d) {
      a2 = true, l = d;
    }, "e"), f: s3(function() {
      try {
        !i && t3.return != null && t3.return();
      } finally {
        if (a2) throw l;
      }
    }, "f") };
  }
  s3(In, "_createForOfIteratorHelper");
  function rl(r3, e2) {
    if (r3) {
      if (typeof r3 == "string") return vn(r3, e2);
      var t3 = Object.prototype.toString.call(r3).slice(8, -1);
      if (t3 === "Object" && r3.constructor && (t3 = r3.constructor.name), t3 === "Map" || t3 === "Set") return Array.from(r3);
      if (t3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t3)) return vn(r3, e2);
    }
  }
  s3(rl, "_unsupportedIterableToArray");
  function vn(r3, e2) {
    (e2 == null || e2 > r3.length) && (e2 = r3.length);
    for (var t3 = 0, o2 = new Array(e2); t3 < e2; t3++)
      o2[t3] = r3[t3];
    return o2;
  }
  s3(vn, "_arrayLikeToArray");
  var tl = xn(), An = {
    fg: "#FFF",
    bg: "#000",
    newline: false,
    escapeXML: false,
    stream: false,
    colors: ol()
  };
  function ol() {
    var r3 = {
      0: "#000",
      1: "#A00",
      2: "#0A0",
      3: "#A50",
      4: "#00A",
      5: "#A0A",
      6: "#0AA",
      7: "#AAA",
      8: "#555",
      9: "#F55",
      10: "#5F5",
      11: "#FF5",
      12: "#55F",
      13: "#F5F",
      14: "#5FF",
      15: "#FFF"
    };
    return fr(0, 5).forEach(function(e2) {
      fr(0, 5).forEach(function(t3) {
        fr(0, 5).forEach(function(o2) {
          return nl(e2, t3, o2, r3);
        });
      });
    }), fr(0, 23).forEach(function(e2) {
      var t3 = e2 + 232, o2 = On(e2 * 10 + 8);
      r3[t3] = "#" + o2 + o2 + o2;
    }), r3;
  }
  s3(ol, "getDefaultColors");
  function nl(r3, e2, t3, o2) {
    var n3 = 16 + r3 * 36 + e2 * 6 + t3, i = r3 > 0 ? r3 * 40 + 55 : 0, a2 = e2 > 0 ? e2 * 40 + 55 : 0, l = t3 > 0 ? t3 * 40 + 55 : 0;
    o2[n3] = sl([i, a2, l]);
  }
  s3(nl, "setStyleColor");
  function On(r3) {
    for (var e2 = r3.toString(16); e2.length < 2; )
      e2 = "0" + e2;
    return e2;
  }
  s3(On, "toHexString");
  function sl(r3) {
    var e2 = [], t3 = In(r3), o2;
    try {
      for (t3.s(); !(o2 = t3.n()).done; ) {
        var n3 = o2.value;
        e2.push(On(n3));
      }
    } catch (i) {
      t3.e(i);
    } finally {
      t3.f();
    }
    return "#" + e2.join("");
  }
  s3(sl, "toColorHexString");
  function Cn(r3, e2, t3, o2) {
    var n3;
    return e2 === "text" ? n3 = cl(t3, o2) : e2 === "display" ? n3 = al(r3, t3, o2) : e2 === "xterm256Foreground" ? n3 = hr(r3, o2.colors[t3]) : e2 === "xterm256Background" ? n3 = mr(r3, o2.colors[t3]) : e2 === "rgb" && (n3 = il(r3, t3)), n3;
  }
  s3(Cn, "generateOutput");
  function il(r3, e2) {
    e2 = e2.substring(2).slice(0, -1);
    var t3 = +e2.substr(0, 2), o2 = e2.substring(5).split(";"), n3 = o2.map(function(i) {
      return ("0" + Number(i).toString(16)).substr(-2);
    }).join("");
    return yr(r3, (t3 === 38 ? "color:#" : "background-color:#") + n3);
  }
  s3(il, "handleRgb");
  function al(r3, e2, t3) {
    e2 = parseInt(e2, 10);
    var o2 = {
      "-1": s3(function() {
        return "<br/>";
      }, "_"),
      0: s3(function() {
        return r3.length && Dn(r3);
      }, "_"),
      1: s3(function() {
        return ne2(r3, "b");
      }, "_"),
      3: s3(function() {
        return ne2(r3, "i");
      }, "_"),
      4: s3(function() {
        return ne2(r3, "u");
      }, "_"),
      8: s3(function() {
        return yr(r3, "display:none");
      }, "_"),
      9: s3(function() {
        return ne2(r3, "strike");
      }, "_"),
      22: s3(function() {
        return yr(r3, "font-weight:normal;text-decoration:none;font-style:normal");
      }, "_"),
      23: s3(function() {
        return Fn(r3, "i");
      }, "_"),
      24: s3(function() {
        return Fn(r3, "u");
      }, "_"),
      39: s3(function() {
        return hr(r3, t3.fg);
      }, "_"),
      49: s3(function() {
        return mr(r3, t3.bg);
      }, "_"),
      53: s3(function() {
        return yr(r3, "text-decoration:overline");
      }, "_")
    }, n3;
    return o2[e2] ? n3 = o2[e2]() : 4 < e2 && e2 < 7 ? n3 = ne2(r3, "blink") : 29 < e2 && e2 < 38 ? n3 = hr(r3, t3.colors[e2 - 30]) : 39 < e2 && e2 < 48 ? n3 = mr(r3, t3.colors[e2 - 40]) : 89 < e2 && e2 < 98 ? n3 = hr(r3, t3.colors[8 + (e2 - 90)]) : 99 < e2 && e2 < 108 && (n3 = mr(r3, t3.colors[8 + (e2 - 100)])), n3;
  }
  s3(al, "handleDisplay");
  function Dn(r3) {
    var e2 = r3.slice(0);
    return r3.length = 0, e2.reverse().map(function(t3) {
      return "</" + t3 + ">";
    }).join("");
  }
  s3(Dn, "resetStyles");
  function fr(r3, e2) {
    for (var t3 = [], o2 = r3; o2 <= e2; o2++)
      t3.push(o2);
    return t3;
  }
  s3(fr, "range");
  function ll(r3) {
    return function(e2) {
      return (r3 === null || e2.category !== r3) && r3 !== "all";
    };
  }
  s3(ll, "notCategory");
  function Pn(r3) {
    r3 = parseInt(r3, 10);
    var e2 = null;
    return r3 === 0 ? e2 = "all" : r3 === 1 ? e2 = "bold" : 2 < r3 && r3 < 5 ? e2 = "underline" : 4 < r3 && r3 < 7 ? e2 = "blink" : r3 === 8 ? e2 = "hide" : r3 === 9 ? e2 = "strike" : 29 < r3 && r3 < 38 || r3 === 39 || 89 < r3 && r3 < 98 ? e2 = "foreground-color" : (39 < r3 && r3 < 48 || r3 === 49 || 99 < r3 && r3 < 108) && (e2 = "background-color"), e2;
  }
  s3(Pn, "categoryForCode");
  function cl(r3, e2) {
    return e2.escapeXML ? tl.encodeXML(r3) : r3;
  }
  s3(cl, "pushText");
  function ne2(r3, e2, t3) {
    return t3 || (t3 = ""), r3.push(e2), "<".concat(e2).concat(t3 ? ' style="'.concat(t3, '"') : "", ">");
  }
  s3(ne2, "pushTag");
  function yr(r3, e2) {
    return ne2(r3, "span", e2);
  }
  s3(yr, "pushStyle");
  function hr(r3, e2) {
    return ne2(r3, "span", "color:" + e2);
  }
  s3(hr, "pushForegroundColor");
  function mr(r3, e2) {
    return ne2(r3, "span", "background-color:" + e2);
  }
  s3(mr, "pushBackgroundColor");
  function Fn(r3, e2) {
    var t3;
    if (r3.slice(-1)[0] === e2 && (t3 = r3.pop()), t3)
      return "</" + e2 + ">";
  }
  s3(Fn, "closeTag");
  function dl(r3, e2, t3) {
    var o2 = false, n3 = 3;
    function i() {
      return "";
    }
    s3(i, "remove");
    function a2(x5, w5) {
      return t3("xterm256Foreground", w5), "";
    }
    s3(a2, "removeXterm256Foreground");
    function l(x5, w5) {
      return t3("xterm256Background", w5), "";
    }
    s3(l, "removeXterm256Background");
    function c(x5) {
      return e2.newline ? t3("display", -1) : t3("text", x5), "";
    }
    s3(c, "newline");
    function d(x5, w5) {
      o2 = true, w5.trim().length === 0 && (w5 = "0"), w5 = w5.trimRight(";").split(";");
      var A3 = In(w5), O4;
      try {
        for (A3.s(); !(O4 = A3.n()).done; ) {
          var N4 = O4.value;
          t3("display", N4);
        }
      } catch (U4) {
        A3.e(U4);
      } finally {
        A3.f();
      }
      return "";
    }
    s3(d, "ansiMess");
    function p4(x5) {
      return t3("text", x5), "";
    }
    s3(p4, "realText");
    function u2(x5) {
      return t3("rgb", x5), "";
    }
    s3(u2, "rgb");
    var y2 = [{
      pattern: /^\x08+/,
      sub: i
    }, {
      pattern: /^\x1b\[[012]?K/,
      sub: i
    }, {
      pattern: /^\x1b\[\(B/,
      sub: i
    }, {
      pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
      sub: u2
    }, {
      pattern: /^\x1b\[38;5;(\d+)m/,
      sub: a2
    }, {
      pattern: /^\x1b\[48;5;(\d+)m/,
      sub: l
    }, {
      pattern: /^\n/,
      sub: c
    }, {
      pattern: /^\r+\n/,
      sub: c
    }, {
      pattern: /^\r/,
      sub: c
    }, {
      pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
      sub: d
    }, {
      // CSI n J
      // ED - Erase in Display Clears part of the screen.
      // If n is 0 (or missing), clear from cursor to end of screen.
      // If n is 1, clear from cursor to beginning of the screen.
      // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
      // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
      //   (this feature was added for xterm and is supported by other terminal applications).
      pattern: /^\x1b\[\d?J/,
      sub: i
    }, {
      // CSI n ; m f
      // HVP - Horizontal Vertical Position Same as CUP
      pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
      sub: i
    }, {
      // catch-all for CSI sequences?
      pattern: /^\x1b\[?[\d;]{0,3}/,
      sub: i
    }, {
      /**
       * extracts real text - not containing:
       * - `\x1b' - ESC - escape (Ascii 27)
       * - '\x08' - BS - backspace (Ascii 8)
       * - `\n` - Newline - linefeed (LF) (ascii 10)
       * - `\r` - Windows Carriage Return (CR)
       */
      pattern: /^(([^\x1b\x08\r\n])+)/,
      sub: p4
    }];
    function m3(x5, w5) {
      w5 > n3 && o2 || (o2 = false, r3 = r3.replace(x5.pattern, x5.sub));
    }
    s3(m3, "process");
    var g = [], S4 = r3, h = S4.length;
    e: for (; h > 0; ) {
      for (var E2 = 0, R4 = 0, f5 = y2.length; R4 < f5; E2 = ++R4) {
        var b5 = y2[E2];
        if (m3(b5, E2), r3.length !== h) {
          h = r3.length;
          continue e;
        }
      }
      if (r3.length === h)
        break;
      g.push(0), h = r3.length;
    }
    return g;
  }
  s3(dl, "tokenize");
  function pl(r3, e2, t3) {
    return e2 !== "text" && (r3 = r3.filter(ll(Pn(t3))), r3.push({
      token: e2,
      data: t3,
      category: Pn(t3)
    })), r3;
  }
  s3(pl, "updateStickyStack");
  var ul = function() {
    function r3(e2) {
      Za(this, r3), e2 = e2 || {}, e2.colors && (e2.colors = Object.assign({}, An.colors, e2.colors)), this.options = Object.assign({}, An, e2), this.stack = [], this.stickyStack = [];
    }
    return s3(r3, "Filter"), el(r3, [{
      key: "toHtml",
      value: s3(function(t3) {
        var o2 = this;
        t3 = typeof t3 == "string" ? [t3] : t3;
        var n3 = this.stack, i = this.options, a2 = [];
        return this.stickyStack.forEach(function(l) {
          var c = Cn(n3, l.token, l.data, i);
          c && a2.push(c);
        }), dl(t3.join(""), i, function(l, c) {
          var d = Cn(n3, l, c, i);
          d && a2.push(d), i.stream && (o2.stickyStack = pl(o2.stickyStack, l, c));
        }), n3.length && a2.push(Dn(n3)), a2.join("");
      }, "toHtml")
    }]), r3;
  }();
  kn.exports = ul;
});
var I5 = (() => {
  let r3;
  return typeof window < "u" ? r3 = window : typeof globalThis < "u" ? r3 = globalThis : typeof global < "u" ? r3 = global : typeof self < "u" ? r3 = self : r3 = {}, r3;
})();
function Tr() {
  let r3 = {
    setHandler: s3(() => {
    }, "setHandler"),
    send: s3(() => {
    }, "send")
  };
  return new B2({ transport: r3 });
}
s3(Tr, "mockChannel");
var xr = class xr2 {
  constructor() {
    this.getChannel = s3(() => {
      if (!this.channel) {
        let e2 = Tr();
        return this.setChannel(e2), e2;
      }
      return this.channel;
    }, "getChannel");
    this.ready = s3(() => this.promise, "ready");
    this.hasChannel = s3(() => !!this.channel, "hasChannel");
    this.setChannel = s3((e2) => {
      this.channel = e2, this.resolve();
    }, "setChannel");
    this.promise = new Promise((e2) => {
      this.resolve = () => e2(this.getChannel());
    });
  }
};
s3(xr, "AddonStore");
var Rr = xr;
var Er = "__STORYBOOK_ADDONS_PREVIEW";
function Xn() {
  return I5[Er] || (I5[Er] = new Rr()), I5[Er];
}
s3(Xn, "getAddonsStore");
var V4 = Xn();
function Jn(r3) {
  return r3;
}
s3(Jn, "definePreview");
var Pr = class Pr2 {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = s3((e2) => {
      var _a;
      e2 === ((_a = this.currentContext) == null ? void 0 : _a.id) && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    }, "renderListener");
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((e2) => {
      e2.destroy && e2.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let e2 = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, e2;
  }
  triggerEffects() {
    this.prevEffects.forEach((e2) => {
      !this.currentEffects.includes(e2) && e2.destroy && e2.destroy();
    }), this.currentEffects.forEach((e2) => {
      this.prevEffects.includes(e2) || (e2.destroy = e2.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), V4.getChannel().on(X, this.renderListener);
  }
  removeRenderListeners() {
    V4.getChannel().removeListener(X, this.renderListener);
  }
};
s3(Pr, "HooksContext");
var se2 = Pr;
function It(r3) {
  let e2 = s3((...t3) => {
    let { hooks: o2 } = typeof t3[0] == "function" ? t3[1] : t3[0], n3 = o2.currentPhase, i = o2.currentHooks, a2 = o2.nextHookIndex, l = o2.currentDecoratorName;
    o2.currentDecoratorName = r3.name, o2.prevMountedDecorators.has(r3) ? (o2.currentPhase = "UPDATE", o2.currentHooks = o2.hookListsMap.get(r3) || []) : (o2.currentPhase = "MOUNT", o2.currentHooks = [], o2.hookListsMap.set(r3, o2.currentHooks), o2.prevMountedDecorators.add(r3)), o2.nextHookIndex = 0;
    let c = I5.STORYBOOK_HOOKS_CONTEXT;
    I5.STORYBOOK_HOOKS_CONTEXT = o2;
    let d = r3(...t3);
    if (I5.STORYBOOK_HOOKS_CONTEXT = c, o2.currentPhase === "UPDATE" && o2.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return o2.currentPhase = n3, o2.currentHooks = i, o2.nextHookIndex = a2, o2.currentDecoratorName = l, d;
  }, "hookified");
  return e2.originalFn = r3, e2;
}
s3(It, "hookify");
var wr = 0;
var ts = 25;
var vr = s3((r3) => (e2, t3) => {
  let o2 = r3(
    It(e2),
    t3.map((n3) => It(n3))
  );
  return (n3) => {
    let { hooks: i } = n3;
    i.prevMountedDecorators ?? (i.prevMountedDecorators = /* @__PURE__ */ new Set()), i.mountedDecorators = /* @__PURE__ */ new Set([e2, ...t3]), i.currentContext = n3, i.hasUpdates = false;
    let a2 = o2(n3);
    for (wr = 1; i.hasUpdates; )
      if (i.hasUpdates = false, i.currentEffects = [], a2 = o2(n3), wr += 1, wr > ts)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return i.addRenderListeners(), a2;
  };
}, "applyHooks");
var os = s3((r3, e2) => r3.length === e2.length && r3.every((t3, o2) => t3 === e2[o2]), "areDepsEqual");
var Ar = s3(
  () => new Error("Storybook preview hooks can only be called inside decorators and story functions."),
  "invalidHooksError"
);
function Ot() {
  return I5.STORYBOOK_HOOKS_CONTEXT || null;
}
s3(Ot, "getHooksContextOrNull");
function Cr() {
  let r3 = Ot();
  if (r3 == null)
    throw Ar();
  return r3;
}
s3(Cr, "getHooksContextOrThrow");
function ns(r3, e2, t3) {
  let o2 = Cr();
  if (o2.currentPhase === "MOUNT") {
    t3 != null && !Array.isArray(t3) && s.warn(
      `${r3} received a final argument that is not an array (instead, received ${t3}). When specified, the final argument must be an array.`
    );
    let n3 = { name: r3, deps: t3 };
    return o2.currentHooks.push(n3), e2(n3), n3;
  }
  if (o2.currentPhase === "UPDATE") {
    let n3 = o2.getNextHook();
    if (n3 == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return n3.name !== r3 && s.warn(
      `Storybook has detected a change in the order of Hooks${o2.currentDecoratorName ? ` called by ${o2.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), t3 != null && n3.deps == null && s.warn(
      `${r3} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), t3 != null && n3.deps != null && t3.length !== n3.deps.length && s.warn(`The final argument passed to ${r3} changed size between renders. The order and size of this array must remain constant.
Previous: ${n3.deps}
Incoming: ${t3}`), (t3 == null || n3.deps == null || !os(t3, n3.deps)) && (e2(n3), n3.deps = t3), n3;
  }
  throw Ar();
}
s3(ns, "useHook");
function He(r3, e2, t3) {
  let { memoizedState: o2 } = ns(
    r3,
    (n3) => {
      n3.memoizedState = e2();
    },
    t3
  );
  return o2;
}
s3(He, "useMemoLike");
function ss(r3, e2) {
  return He("useMemo", r3, e2);
}
s3(ss, "useMemo");
function Oe(r3, e2) {
  return He("useCallback", () => r3, e2);
}
s3(Oe, "useCallback");
function Dt(r3, e2) {
  return He(r3, () => ({ current: e2 }), []);
}
s3(Dt, "useRefLike");
function is(r3) {
  return Dt("useRef", r3);
}
s3(is, "useRef");
function as() {
  let r3 = Ot();
  if (r3 != null && r3.currentPhase !== "NONE")
    r3.hasUpdates = true;
  else
    try {
      V4.getChannel().emit(L);
    } catch {
      s.warn("State updates of Storybook preview hooks work only in browser");
    }
}
s3(as, "triggerUpdate");
function kt(r3, e2) {
  let t3 = Dt(
    r3,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof e2 == "function" ? e2() : e2
  ), o2 = s3((n3) => {
    t3.current = typeof n3 == "function" ? n3(t3.current) : n3, as();
  }, "setState");
  return [t3.current, o2];
}
s3(kt, "useStateLike");
function ls(r3) {
  return kt("useState", r3);
}
s3(ls, "useState");
function cs(r3, e2, t3) {
  let o2 = t3 != null ? () => t3(e2) : e2, [n3, i] = kt("useReducer", o2);
  return [n3, s3((l) => i((c) => r3(c, l)), "dispatch")];
}
s3(cs, "useReducer");
function jt(r3, e2) {
  let t3 = Cr(), o2 = He("useEffect", () => ({ create: r3 }), e2);
  t3.currentEffects.includes(o2) || t3.currentEffects.push(o2);
}
s3(jt, "useEffect");
function ds(r3, e2 = []) {
  let t3 = V4.getChannel();
  return jt(() => (Object.entries(r3).forEach(([o2, n3]) => t3.on(o2, n3)), () => {
    Object.entries(r3).forEach(
      ([o2, n3]) => t3.removeListener(o2, n3)
    );
  }), [...Object.keys(r3), ...e2]), Oe(t3.emit.bind(t3), [t3]);
}
s3(ds, "useChannel");
function We() {
  let { currentContext: r3 } = Cr();
  if (r3 == null)
    throw Ar();
  return r3;
}
s3(We, "useStoryContext");
function ps(r3, e2) {
  let { parameters: t3 } = We();
  if (r3)
    return t3[r3] ?? e2;
}
s3(ps, "useParameter");
function us() {
  let r3 = V4.getChannel(), { id: e2, args: t3 } = We(), o2 = Oe(
    (i) => r3.emit(z, { storyId: e2, updatedArgs: i }),
    [r3, e2]
  ), n3 = Oe(
    (i) => r3.emit(W, { storyId: e2, argNames: i }),
    [r3, e2]
  );
  return [t3, o2, n3];
}
s3(us, "useArgs");
function fs() {
  let r3 = V4.getChannel(), { globals: e2 } = We(), t3 = Oe(
    (o2) => r3.emit(k, { globals: o2 }),
    [r3]
  );
  return [e2, t3];
}
s3(fs, "useGlobals");
var ys = s3(({
  name: r3,
  parameterName: e2,
  wrapper: t3,
  skipIfNoParametersOrOptions: o2 = false
}) => {
  let n3 = s3((i) => (a2, l) => {
    let c = l.parameters && l.parameters[e2];
    return c && c.disable || o2 && !i && !c ? a2(l) : t3(a2, l, {
      options: i,
      parameters: c
    });
  }, "decorator");
  return (...i) => typeof i[0] == "function" ? n3()(...i) : (...a2) => {
    if (a2.length > 1)
      return i.length > 1 ? n3(i)(...a2) : n3(...i)(...a2);
    throw new Error(
      `Passing stories directly into ${r3}() is not allowed,
        instead use addDecorator(${r3}) and pass options with the '${e2}' parameter`
    );
  };
}, "makeDecorator");
function P5(r3) {
  for (var e2 = [], t3 = 1; t3 < arguments.length; t3++)
    e2[t3 - 1] = arguments[t3];
  var o2 = Array.from(typeof r3 == "string" ? [r3] : r3);
  o2[o2.length - 1] = o2[o2.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var n3 = o2.reduce(function(l, c) {
    var d = c.match(/\n([\t ]+|(?!\s).)/g);
    return d ? l.concat(d.map(function(p4) {
      var u2, y2;
      return (y2 = (u2 = p4.match(/[\t ]/g)) === null || u2 === void 0 ? void 0 : u2.length) !== null && y2 !== void 0 ? y2 : 0;
    })) : l;
  }, []);
  if (n3.length) {
    var i = new RegExp(`
[	 ]{` + Math.min.apply(Math, n3) + "}", "g");
    o2 = o2.map(function(l) {
      return l.replace(i, `
`);
    });
  }
  o2[0] = o2[0].replace(/^\r?\n/, "");
  var a2 = o2[0];
  return e2.forEach(function(l, c) {
    var d = a2.match(/(?:^|\n)( *)$/), p4 = d ? d[1] : "", u2 = l;
    typeof l == "string" && l.includes(`
`) && (u2 = String(l).split(`
`).map(function(y2, m3) {
      return m3 === 0 ? y2 : "" + p4 + y2;
    }).join(`
`)), a2 += u2 + o2[c + 1];
  }), a2;
}
s3(P5, "dedent");
var Lt = P5;
var Fr = /* @__PURE__ */ new Map();
var hs = "UNIVERSAL_STORE:";
var q3 = {
  PENDING: "PENDING",
  RESOLVED: "RESOLVED",
  REJECTED: "REJECTED"
};
var T4 = class T5 {
  constructor(e2, t3) {
    this.debugging = false;
    this.listeners = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set()]]);
    this.getState = s3(() => (this.debug("getState", { state: this.state }), this.state), "getState");
    this.subscribe = s3((e3, t4) => {
      let o2 = typeof e3 == "function", n3 = o2 ? "*" : e3, i = o2 ? e3 : t4;
      if (this.debug("subscribe", { eventType: n3, listener: i }), !i)
        throw new TypeError(
          `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
        );
      return this.listeners.has(n3) || this.listeners.set(n3, /* @__PURE__ */ new Set()), this.listeners.get(n3).add(i), () => {
        var _a;
        this.debug("unsubscribe", { eventType: n3, listener: i }), this.listeners.has(n3) && (this.listeners.get(n3).delete(i), ((_a = this.listeners.get(n3)) == null ? void 0 : _a.size) === 0 && this.listeners.delete(n3));
      };
    }, "subscribe");
    this.send = s3((e3) => {
      if (this.debug("send", { event: e3 }), this.status !== T5.Status.READY)
        throw new TypeError(
          P5`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
            {
              event: e3,
              id: this.id,
              actor: this.actor,
              environment: this.environment
            },
            null,
            2
          )}`
        );
      this.emitToListeners(e3, { actor: this.actor }), this.emitToChannel(e3, { actor: this.actor });
    }, "send");
    if (this.debugging = e2.debug ?? false, !T5.isInternalConstructing)
      throw new TypeError(
        "UniversalStore is not constructable - use UniversalStore.create() instead"
      );
    if (T5.isInternalConstructing = false, this.id = e2.id, this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2), this.actorType = e2.leader ? T5.ActorType.LEADER : T5.ActorType.FOLLOWER, this.state = e2.initialState, this.channelEventName = `${hs}${this.id}`, this.debug("constructor", {
      options: e2,
      environmentOverrides: t3,
      channelEventName: this.channelEventName
    }), this.actor.type === T5.ActorType.LEADER)
      this.syncing = {
        state: q3.RESOLVED,
        promise: Promise.resolve()
      };
    else {
      let o2, n3, i = new Promise((a2, l) => {
        o2 = s3(() => {
          this.syncing.state === q3.PENDING && (this.syncing.state = q3.RESOLVED, a2());
        }, "syncingResolve"), n3 = s3((c) => {
          this.syncing.state === q3.PENDING && (this.syncing.state = q3.REJECTED, l(c));
        }, "syncingReject");
      });
      this.syncing = {
        state: q3.PENDING,
        promise: i,
        resolve: o2,
        reject: n3
      };
    }
    this.getState = this.getState.bind(this), this.setState = this.setState.bind(this), this.subscribe = this.subscribe.bind(this), this.onStateChange = this.onStateChange.bind(this), this.send = this.send.bind(this), this.emitToChannel = this.emitToChannel.bind(this), this.prepareThis = this.prepareThis.bind(this), this.emitToListeners = this.emitToListeners.bind(this), this.handleChannelEvents = this.handleChannelEvents.bind(
      this
    ), this.debug = this.debug.bind(this), this.channel = (t3 == null ? void 0 : t3.channel) ?? T5.preparation.channel, this.environment = (t3 == null ? void 0 : t3.environment) ?? T5.preparation.environment, this.channel && this.environment ? this.prepareThis({ channel: this.channel, environment: this.environment }) : T5.preparation.promise.then(this.prepareThis);
  }
  static setupPreparationPromise() {
    let e2, t3, o2 = new Promise(
      (n3, i) => {
        e2 = s3((a2) => {
          n3(a2);
        }, "resolveRef"), t3 = s3((...a2) => {
          i(a2);
        }, "rejectRef");
      }
    );
    T5.preparation = {
      resolve: e2,
      reject: t3,
      promise: o2
    };
  }
  /** The actor object representing the store instance with a unique ID and a type */
  get actor() {
    return Object.freeze({
      id: this.actorId,
      type: this.actorType,
      environment: this.environment ?? T5.Environment.UNKNOWN
    });
  }
  /**
   * The current state of the store, that signals both if the store is prepared by Storybook and
   * also - in the case of a follower - if the state has been synced with the leader's state.
   */
  get status() {
    var _a;
    if (!this.channel || !this.environment)
      return T5.Status.UNPREPARED;
    switch ((_a = this.syncing) == null ? void 0 : _a.state) {
      case q3.PENDING:
      case void 0:
        return T5.Status.SYNCING;
      case q3.REJECTED:
        return T5.Status.ERROR;
      case q3.RESOLVED:
      default:
        return T5.Status.READY;
    }
  }
  /**
   * A promise that resolves when the store is fully ready. A leader will be ready when the store
   * has been prepared by Storybook, which is almost instantly.
   *
   * A follower will be ready when the state has been synced with the leader's state, within a few
   * hundred milliseconds.
   */
  untilReady() {
    var _a;
    return Promise.all([T5.preparation.promise, (_a = this.syncing) == null ? void 0 : _a.promise]);
  }
  /** Creates a new instance of UniversalStore */
  static create(e2) {
    if (!e2 || typeof (e2 == null ? void 0 : e2.id) != "string")
      throw new TypeError("id is required and must be a string, when creating a UniversalStore");
    e2.debug && console.debug(
      P5`[UniversalStore]
        create`,
      { options: e2 }
    );
    let t3 = Fr.get(e2.id);
    if (t3)
      return console.warn(P5`UniversalStore with id "${e2.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`), t3;
    T5.isInternalConstructing = true;
    let o2 = new T5(e2);
    return Fr.set(e2.id, o2), o2;
  }
  /**
   * Used by Storybook to set the channel for all instances of UniversalStore in the given
   * environment.
   *
   * @internal
   */
  static __prepare(e2, t3) {
    T5.preparation.channel = e2, T5.preparation.environment = t3, T5.preparation.resolve({ channel: e2, environment: t3 });
  }
  /**
   * Updates the store's state
   *
   * Either a new state or a state updater function can be passed to the method.
   */
  setState(e2) {
    let t3 = this.state, o2 = typeof e2 == "function" ? e2(t3) : e2;
    if (this.debug("setState", { newState: o2, previousState: t3, updater: e2 }), this.status !== T5.Status.READY)
      throw new TypeError(
        P5`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
          {
            newState: o2,
            id: this.id,
            actor: this.actor,
            environment: this.environment
          },
          null,
          2
        )}`
      );
    this.state = o2;
    let n3 = {
      type: T5.InternalEventType.SET_STATE,
      payload: {
        state: o2,
        previousState: t3
      }
    };
    this.emitToChannel(n3, { actor: this.actor }), this.emitToListeners(n3, { actor: this.actor });
  }
  /**
   * Subscribes to state changes
   *
   * @returns Unsubscribe function
   */
  onStateChange(e2) {
    return this.debug("onStateChange", { listener: e2 }), this.subscribe(
      T5.InternalEventType.SET_STATE,
      ({ payload: t3 }, o2) => {
        e2(t3.state, t3.previousState, o2);
      }
    );
  }
  emitToChannel(e2, t3) {
    var _a;
    this.debug("emitToChannel", { event: e2, eventInfo: t3, channel: this.channel }), (_a = this.channel) == null ? void 0 : _a.emit(this.channelEventName, {
      event: e2,
      eventInfo: t3
    });
  }
  prepareThis({
    channel: e2,
    environment: t3
  }) {
    this.channel = e2, this.environment = t3, this.debug("prepared", { channel: e2, environment: t3 }), this.channel.on(this.channelEventName, this.handleChannelEvents), this.actor.type === T5.ActorType.LEADER ? this.emitToChannel(
      { type: T5.InternalEventType.LEADER_CREATED },
      { actor: this.actor }
    ) : (this.emitToChannel(
      { type: T5.InternalEventType.FOLLOWER_CREATED },
      { actor: this.actor }
    ), this.emitToChannel(
      { type: T5.InternalEventType.EXISTING_STATE_REQUEST },
      { actor: this.actor }
    ), setTimeout(() => {
      this.syncing.reject(
        new TypeError(
          `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`
        )
      );
    }, 1e3));
  }
  emitToListeners(e2, t3) {
    let o2 = this.listeners.get(e2.type), n3 = this.listeners.get("*");
    this.debug("emitToListeners", {
      event: e2,
      eventInfo: t3,
      eventTypeListeners: o2,
      everythingListeners: n3
    }), [...o2 ?? [], ...n3 ?? []].forEach(
      (i) => i(e2, t3)
    );
  }
  handleChannelEvents(e2) {
    var _a, _b, _c, _d, _e2;
    let { event: t3, eventInfo: o2 } = e2;
    if ([o2.actor.id, (_a = o2.forwardingActor) == null ? void 0 : _a.id].includes(this.actor.id)) {
      this.debug("handleChannelEvents: Ignoring event from self", { channelEvent: e2 });
      return;
    } else if (((_b = this.syncing) == null ? void 0 : _b.state) === q3.PENDING && t3.type !== T5.InternalEventType.EXISTING_STATE_RESPONSE) {
      this.debug("handleChannelEvents: Ignoring event while syncing", { channelEvent: e2 });
      return;
    }
    if (this.debug("handleChannelEvents", { channelEvent: e2 }), this.actor.type === T5.ActorType.LEADER) {
      let n3 = true;
      switch (t3.type) {
        case T5.InternalEventType.EXISTING_STATE_REQUEST:
          n3 = false;
          let i = {
            type: T5.InternalEventType.EXISTING_STATE_RESPONSE,
            payload: this.state
          };
          this.debug("handleChannelEvents: responding to existing state request", {
            responseEvent: i
          }), this.emitToChannel(i, { actor: this.actor });
          break;
        case T5.InternalEventType.LEADER_CREATED:
          n3 = false, this.syncing.state = q3.REJECTED, this.debug("handleChannelEvents: erroring due to second leader being created", {
            event: t3
          }), console.error(
            P5`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(o2.actor, null, 2)}`
          );
          break;
      }
      n3 && (this.debug("handleChannelEvents: forwarding event", { channelEvent: e2 }), this.emitToChannel(t3, { actor: o2.actor, forwardingActor: this.actor }));
    }
    if (this.actor.type === T5.ActorType.FOLLOWER)
      switch (t3.type) {
        case T5.InternalEventType.EXISTING_STATE_RESPONSE:
          if (this.debug("handleChannelEvents: Setting state from leader's existing state response", {
            event: t3
          }), ((_c = this.syncing) == null ? void 0 : _c.state) !== q3.PENDING)
            break;
          (_e2 = (_d = this.syncing).resolve) == null ? void 0 : _e2.call(_d);
          let n3 = {
            type: T5.InternalEventType.SET_STATE,
            payload: {
              state: t3.payload,
              previousState: this.state
            }
          };
          this.state = t3.payload, this.emitToListeners(n3, o2);
          break;
      }
    switch (t3.type) {
      case T5.InternalEventType.SET_STATE:
        this.debug("handleChannelEvents: Setting state", { event: t3 }), this.state = t3.payload.state;
        break;
    }
    this.emitToListeners(t3, { actor: o2.actor });
  }
  debug(e2, t3) {
    this.debugging && console.debug(
      P5`[UniversalStore::${this.id}::${this.environment ?? T5.Environment.UNKNOWN}]
        ${e2}`,
      JSON.stringify(
        {
          data: t3,
          actor: this.actor,
          state: this.state,
          status: this.status
        },
        null,
        2
      )
    );
  }
  /**
   * Used to reset the static fields of the UniversalStore class when cleaning up tests
   *
   * @internal
   */
  static __reset() {
    T5.preparation.reject(new Error("reset")), T5.setupPreparationPromise(), T5.isInternalConstructing = false;
  }
};
s3(T4, "UniversalStore"), /**
* Defines the possible actor types in the store system
*
* @readonly
*/
T4.ActorType = {
  LEADER: "LEADER",
  FOLLOWER: "FOLLOWER"
}, /**
* Defines the possible environments the store can run in
*
* @readonly
*/
T4.Environment = {
  SERVER: "SERVER",
  MANAGER: "MANAGER",
  PREVIEW: "PREVIEW",
  UNKNOWN: "UNKNOWN",
  MOCK: "MOCK"
}, /**
* Internal event types used for store synchronization
*
* @readonly
*/
T4.InternalEventType = {
  EXISTING_STATE_REQUEST: "__EXISTING_STATE_REQUEST",
  EXISTING_STATE_RESPONSE: "__EXISTING_STATE_RESPONSE",
  SET_STATE: "__SET_STATE",
  LEADER_CREATED: "__LEADER_CREATED",
  FOLLOWER_CREATED: "__FOLLOWER_CREATED"
}, T4.Status = {
  UNPREPARED: "UNPREPARED",
  SYNCING: "SYNCING",
  READY: "READY",
  ERROR: "ERROR"
}, // This is used to check if constructor was called from the static factory create()
T4.isInternalConstructing = false, T4.setupPreparationPromise();
var J2 = T4;
function Ir(r3, e2) {
  let t3 = {}, o2 = Object.entries(r3);
  for (let n3 = 0; n3 < o2.length; n3++) {
    let [i, a2] = o2[n3];
    e2(a2, i) || (t3[i] = a2);
  }
  return t3;
}
s3(Ir, "omitBy");
function Or(r3, e2) {
  let t3 = {};
  for (let o2 = 0; o2 < e2.length; o2++) {
    let n3 = e2[o2];
    Object.prototype.hasOwnProperty.call(r3, n3) && (t3[n3] = r3[n3]);
  }
  return t3;
}
s3(Or, "pick");
function Dr(r3, e2) {
  let t3 = {}, o2 = Object.entries(r3);
  for (let n3 = 0; n3 < o2.length; n3++) {
    let [i, a2] = o2[n3];
    e2(a2, i) && (t3[i] = a2);
  }
  return t3;
}
s3(Dr, "pickBy");
function L4(r3) {
  if (typeof r3 != "object" || r3 == null)
    return false;
  if (Object.getPrototypeOf(r3) === null)
    return true;
  if (r3.toString() !== "[object Object]")
    return false;
  let e2 = r3;
  for (; Object.getPrototypeOf(e2) !== null; )
    e2 = Object.getPrototypeOf(e2);
  return Object.getPrototypeOf(r3) === e2;
}
s3(L4, "isPlainObject");
function G2(r3, e2) {
  let t3 = {}, o2 = Object.keys(r3);
  for (let n3 = 0; n3 < o2.length; n3++) {
    let i = o2[n3], a2 = r3[i];
    t3[i] = e2(a2, i, r3);
  }
  return t3;
}
s3(G2, "mapValues");
var Nt = "[object RegExp]";
var Mt = "[object String]";
var _t = "[object Number]";
var qt = "[object Boolean]";
var kr = "[object Arguments]";
var Ut = "[object Symbol]";
var Gt = "[object Date]";
var Bt = "[object Map]";
var zt = "[object Set]";
var Vt = "[object Array]";
var Ht = "[object Function]";
var Wt = "[object ArrayBuffer]";
var $e = "[object Object]";
var $t = "[object Error]";
var Yt = "[object DataView]";
var Kt = "[object Uint8Array]";
var Xt = "[object Uint8ClampedArray]";
var Jt = "[object Uint16Array]";
var Qt = "[object Uint32Array]";
var Zt = "[object BigUint64Array]";
var eo = "[object Int8Array]";
var ro = "[object Int16Array]";
var to = "[object Int32Array]";
var oo = "[object BigInt64Array]";
var no = "[object Float32Array]";
var so = "[object Float64Array]";
function jr(r3) {
  return Object.getOwnPropertySymbols(r3).filter((e2) => Object.prototype.propertyIsEnumerable.call(r3, e2));
}
s3(jr, "getSymbols");
function Lr(r3) {
  return r3 == null ? r3 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r3);
}
s3(Lr, "getTag");
function De(r3, e2) {
  if (typeof r3 == typeof e2)
    switch (typeof r3) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return r3 === e2;
      case "number":
        return r3 === e2 || Object.is(r3, e2);
      case "function":
        return r3 === e2;
      case "object":
        return Y3(r3, e2);
    }
  return Y3(r3, e2);
}
s3(De, "isEqual");
function Y3(r3, e2, t3) {
  if (Object.is(r3, e2))
    return true;
  let o2 = Lr(r3), n3 = Lr(e2);
  if (o2 === kr && (o2 = $e), n3 === kr && (n3 = $e), o2 !== n3)
    return false;
  switch (o2) {
    case Mt:
      return r3.toString() === e2.toString();
    case _t: {
      let l = r3.valueOf(), c = e2.valueOf();
      return l === c || Number.isNaN(l) && Number.isNaN(c);
    }
    case qt:
    case Gt:
    case Ut:
      return Object.is(r3.valueOf(), e2.valueOf());
    case Nt:
      return r3.source === e2.source && r3.flags === e2.flags;
    case Ht:
      return r3 === e2;
  }
  t3 = t3 ?? /* @__PURE__ */ new Map();
  let i = t3.get(r3), a2 = t3.get(e2);
  if (i != null && a2 != null)
    return i === e2;
  t3.set(r3, e2), t3.set(e2, r3);
  try {
    switch (o2) {
      case Bt: {
        if (r3.size !== e2.size)
          return false;
        for (let [l, c] of r3.entries())
          if (!e2.has(l) || !Y3(c, e2.get(l), t3))
            return false;
        return true;
      }
      case zt: {
        if (r3.size !== e2.size)
          return false;
        let l = Array.from(r3.values()), c = Array.from(e2.values());
        for (let d = 0; d < l.length; d++) {
          let p4 = l[d], u2 = c.findIndex((y2) => Y3(p4, y2, t3));
          if (u2 === -1)
            return false;
          c.splice(u2, 1);
        }
        return true;
      }
      case Vt:
      case Kt:
      case Xt:
      case Jt:
      case Qt:
      case Zt:
      case eo:
      case ro:
      case to:
      case oo:
      case no:
      case so: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r3) !== Buffer.isBuffer(e2) || r3.length !== e2.length)
          return false;
        for (let l = 0; l < r3.length; l++)
          if (!Y3(r3[l], e2[l], t3))
            return false;
        return true;
      }
      case Wt:
        return r3.byteLength !== e2.byteLength ? false : Y3(new Uint8Array(r3), new Uint8Array(e2), t3);
      case Yt:
        return r3.byteLength !== e2.byteLength || r3.byteOffset !== e2.byteOffset ? false : Y3(r3.buffer, e2.buffer, t3);
      case $t:
        return r3.name === e2.name && r3.message === e2.message;
      case $e: {
        if (!(Y3(r3.constructor, e2.constructor, t3) || L4(r3) && L4(e2)))
          return false;
        let c = [...Object.keys(r3), ...jr(r3)], d = [...Object.keys(e2), ...jr(e2)];
        if (c.length !== d.length)
          return false;
        for (let p4 = 0; p4 < c.length; p4++) {
          let u2 = c[p4], y2 = r3[u2];
          if (!Object.prototype.hasOwnProperty.call(e2, u2))
            return false;
          let m3 = e2[u2];
          if (!Y3(y2, m3, t3))
            return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t3.delete(r3), t3.delete(e2);
  }
}
s3(Y3, "areObjectsEqual");
var Ss = s3((r3, e2) => {
  let [t3, o2] = ls(
    e2 ? e2(r3.getState()) : r3.getState()
  );
  return jt(() => r3.onStateChange((n3, i) => {
    if (!e2) {
      o2(n3);
      return;
    }
    let a2 = e2(n3), l = e2(i);
    !De(a2, l) && o2(a2);
  }), [r3, o2, e2]), [t3, r3.setState];
}, "useUniversalStore");
var Ye = class Ye2 extends J2 {
  constructor(e2, t3) {
    J2.isInternalConstructing = true, super(
      { ...e2, leader: true },
      { channel: new B2({}), environment: J2.Environment.MOCK }
    ), J2.isInternalConstructing = false, typeof (t3 == null ? void 0 : t3.fn) == "function" && (this.testUtils = t3, this.getState = t3.fn(this.getState), this.setState = t3.fn(this.setState), this.subscribe = t3.fn(this.subscribe), this.onStateChange = t3.fn(this.onStateChange), this.send = t3.fn(this.send));
  }
  /** Create a mock universal store. This is just an alias for the constructor */
  static create(e2, t3) {
    return new Ye2(e2, t3);
  }
  unsubscribeAll() {
    var _a, _b;
    if (!this.testUtils)
      throw new Error(
        Lt`Cannot call unsubscribeAll on a store that does not have testUtils.
        Please provide testUtils as the second argument when creating the store.`
      );
    let e2 = s3((t3) => {
      try {
        t3.value();
      } catch {
      }
    }, "callReturnedUnsubscribeFn");
    (_a = this.subscribe.mock) == null ? void 0 : _a.results.forEach(e2), (_b = this.onStateChange.mock) == null ? void 0 : _b.results.forEach(e2);
  }
};
s3(Ye, "MockUniversalStore");
var tr = he(_r(), 1);
var me = Symbol("incompatible");
var Ur = s3((r3, e2) => {
  let t3 = e2.type;
  if (r3 == null || !t3 || e2.mapping)
    return r3;
  switch (t3.name) {
    case "string":
      return String(r3);
    case "enum":
      return r3;
    case "number":
      return Number(r3);
    case "boolean":
      return String(r3) === "true";
    case "array":
      return !t3.value || !Array.isArray(r3) ? me : r3.reduce((o2, n3, i) => {
        let a2 = Ur(n3, { type: t3.value });
        return a2 !== me && (o2[i] = a2), o2;
      }, new Array(r3.length));
    case "object":
      return typeof r3 == "string" || typeof r3 == "number" ? r3 : !t3.value || typeof r3 != "object" ? me : Object.entries(r3).reduce((o2, [n3, i]) => {
        let a2 = Ur(i, { type: t3.value[n3] });
        return a2 === me ? o2 : Object.assign(o2, { [n3]: a2 });
      }, {});
    default:
      return me;
  }
}, "map");
var ao = s3((r3, e2) => Object.entries(r3).reduce((t3, [o2, n3]) => {
  if (!e2[o2])
    return t3;
  let i = Ur(n3, e2[o2]);
  return i === me ? t3 : Object.assign(t3, { [o2]: i });
}, {}), "mapArgsToTypes");
var ke = s3((r3, e2) => Array.isArray(r3) && Array.isArray(e2) ? e2.reduce(
  (t3, o2, n3) => (t3[n3] = ke(r3[n3], e2[n3]), t3),
  [...r3]
).filter((t3) => t3 !== void 0) : !L4(r3) || !L4(e2) ? e2 : Object.keys({ ...r3, ...e2 }).reduce((t3, o2) => {
  if (o2 in e2) {
    let n3 = ke(r3[o2], e2[o2]);
    n3 !== void 0 && (t3[o2] = n3);
  } else
    t3[o2] = r3[o2];
  return t3;
}, {}), "combineArgs");
var lo = s3((r3, e2) => Object.entries(e2).reduce((t3, [o2, { options: n3 }]) => {
  function i() {
    return o2 in r3 && (t3[o2] = r3[o2]), t3;
  }
  if (s3(i, "allowArg"), !n3)
    return i();
  if (!Array.isArray(n3))
    return n.error(P5`
        Invalid argType: '${o2}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types
      `), i();
  if (n3.some((u2) => u2 && ["object", "function"].includes(typeof u2)))
    return n.error(P5`
        Invalid argType: '${o2}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
      `), i();
  let a2 = Array.isArray(r3[o2]), l = a2 && r3[o2].findIndex((u2) => !n3.includes(u2)), c = a2 && l === -1;
  if (r3[o2] === void 0 || n3.includes(r3[o2]) || c)
    return i();
  let d = a2 ? `${o2}[${l}]` : o2, p4 = n3.map((u2) => typeof u2 == "string" ? `'${u2}'` : String(u2)).join(", ");
  return n.warn(`Received illegal value for '${d}'. Supported options: ${p4}`), t3;
}, {}), "validateOptions");
var ie = Symbol("Deeply equal");
var ge = s3((r3, e2) => {
  if (typeof r3 != typeof e2)
    return e2;
  if (De(r3, e2))
    return ie;
  if (Array.isArray(r3) && Array.isArray(e2)) {
    let t3 = e2.reduce((o2, n3, i) => {
      let a2 = ge(r3[i], n3);
      return a2 !== ie && (o2[i] = a2), o2;
    }, new Array(e2.length));
    return e2.length >= r3.length ? t3 : t3.concat(new Array(r3.length - e2.length).fill(void 0));
  }
  return L4(r3) && L4(e2) ? Object.keys({ ...r3, ...e2 }).reduce((t3, o2) => {
    let n3 = ge(r3 == null ? void 0 : r3[o2], e2 == null ? void 0 : e2[o2]);
    return n3 === ie ? t3 : Object.assign(t3, { [o2]: n3 });
  }, {}) : e2;
}, "deepDiff");
var Gr = "UNTARGETED";
function co({
  args: r3,
  argTypes: e2
}) {
  let t3 = {};
  return Object.entries(r3).forEach(([o2, n3]) => {
    let { target: i = Gr } = e2[o2] || {};
    t3[i] = t3[i] || {}, t3[i][o2] = n3;
  }), t3;
}
s3(co, "groupArgsByTarget");
function Ts(r3) {
  return Object.keys(r3).forEach((e2) => r3[e2] === void 0 && delete r3[e2]), r3;
}
s3(Ts, "deleteUndefined");
var Br = class Br2 {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(e2) {
    if (!(e2 in this.argsByStoryId))
      throw new Error(`No args known for ${e2} -- has it been rendered yet?`);
    return this.argsByStoryId[e2];
  }
  setInitial(e2) {
    if (!this.initialArgsByStoryId[e2.id])
      this.initialArgsByStoryId[e2.id] = e2.initialArgs, this.argsByStoryId[e2.id] = e2.initialArgs;
    else if (this.initialArgsByStoryId[e2.id] !== e2.initialArgs) {
      let t3 = ge(this.initialArgsByStoryId[e2.id], this.argsByStoryId[e2.id]);
      this.initialArgsByStoryId[e2.id] = e2.initialArgs, this.argsByStoryId[e2.id] = e2.initialArgs, t3 !== ie && this.updateFromDelta(e2, t3);
    }
  }
  updateFromDelta(e2, t3) {
    let o2 = lo(t3, e2.argTypes);
    this.argsByStoryId[e2.id] = ke(this.argsByStoryId[e2.id], o2);
  }
  updateFromPersisted(e2, t3) {
    let o2 = ao(t3, e2.argTypes);
    return this.updateFromDelta(e2, o2);
  }
  update(e2, t3) {
    if (!(e2 in this.argsByStoryId))
      throw new Error(`No args known for ${e2} -- has it been rendered yet?`);
    this.argsByStoryId[e2] = Ts({
      ...this.argsByStoryId[e2],
      ...t3
    });
  }
};
s3(Br, "ArgsStore");
var Ke = Br;
var Xe = s3((r3 = {}) => Object.entries(r3).reduce((e2, [t3, { defaultValue: o2 }]) => (typeof o2 < "u" && (e2[t3] = o2), e2), {}), "getValuesFromArgTypes");
var zr = class zr2 {
  constructor({
    globals: e2 = {},
    globalTypes: t3 = {}
  }) {
    this.set({ globals: e2, globalTypes: t3 });
  }
  set({ globals: e2 = {}, globalTypes: t3 = {} }) {
    let o2 = this.initialGlobals && ge(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(e2), ...Object.keys(t3)]);
    let n3 = Xe(t3);
    this.initialGlobals = { ...n3, ...e2 }, this.globals = this.initialGlobals, o2 && o2 !== ie && this.updateFromPersisted(o2);
  }
  filterAllowedGlobals(e2) {
    return Object.entries(e2).reduce((t3, [o2, n3]) => (this.allowedGlobalNames.has(o2) ? t3[o2] = n3 : s.warn(
      `Attempted to set a global (${o2}) that is not defined in initial globals or globalTypes`
    ), t3), {});
  }
  updateFromPersisted(e2) {
    let t3 = this.filterAllowedGlobals(e2);
    this.globals = { ...this.globals, ...t3 };
  }
  get() {
    return this.globals;
  }
  update(e2) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(e2) };
  }
};
s3(zr, "GlobalsStore");
var Je = zr;
var po = he(_r(), 1);
var xs = (0, po.default)(1)(
  (r3) => Object.values(r3).reduce(
    (e2, t3) => (e2[t3.importPath] = e2[t3.importPath] || t3, e2),
    {}
  )
);
var Vr = class Vr2 {
  constructor({ entries: e2 } = { v: 5, entries: {} }) {
    this.entries = e2;
  }
  entryFromSpecifier(e2) {
    let t3 = Object.values(this.entries);
    if (e2 === "*")
      return t3[0];
    if (typeof e2 == "string")
      return this.entries[e2] ? this.entries[e2] : t3.find((i) => i.id.startsWith(e2));
    let { name: o2, title: n3 } = e2;
    return t3.find((i) => i.name === o2 && i.title === n3);
  }
  storyIdToEntry(e2) {
    let t3 = this.entries[e2];
    if (!t3)
      throw new D2({ storyId: e2 });
    return t3;
  }
  importPathToEntry(e2) {
    return xs(this.entries)[e2];
  }
};
s3(Vr, "StoryIndexStore");
var Qe = Vr;
var ws = s3((r3) => typeof r3 == "string" ? { name: r3 } : r3, "normalizeType");
var vs = s3((r3) => typeof r3 == "string" ? { type: r3 } : r3, "normalizeControl");
var As = s3((r3, e2) => {
  let { type: t3, control: o2, ...n3 } = r3, i = {
    name: e2,
    ...n3
  };
  return t3 && (i.type = ws(t3)), o2 ? i.control = vs(o2) : o2 === false && (i.control = { disable: true }), i;
}, "normalizeInputType");
var ae = s3((r3) => G2(r3, As), "normalizeInputTypes");
var F2 = s3((r3) => Array.isArray(r3) ? r3 : r3 ? [r3] : [], "normalizeArrays");
var Os = P5`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function Se(r3, e2, t3) {
  let o2 = e2, n3 = typeof e2 == "function" ? e2 : null, { story: i } = o2;
  i && (s.debug("deprecated story", i), m(Os));
  let a2 = re(r3), l = typeof o2 != "function" && o2.name || o2.storyName || (i == null ? void 0 : i.name) || a2, c = [
    ...F2(o2.decorators),
    ...F2(i == null ? void 0 : i.decorators)
  ], d = { ...i == null ? void 0 : i.parameters, ...o2.parameters }, p4 = { ...i == null ? void 0 : i.args, ...o2.args }, u2 = { ...i == null ? void 0 : i.argTypes, ...o2.argTypes }, y2 = [...F2(o2.loaders), ...F2(
    i == null ? void 0 : i.loaders
  )], m3 = [
    ...F2(o2.beforeEach),
    ...F2(i == null ? void 0 : i.beforeEach)
  ], g = [
    ...F2(o2.experimental_afterEach),
    ...F2(i == null ? void 0 : i.experimental_afterEach)
  ], { render: S4, play: h, tags: E2 = [], globals: R4 = {} } = o2, f5 = d.__id || ee2(t3.id, a2);
  return {
    moduleExport: e2,
    id: f5,
    name: l,
    tags: E2,
    decorators: c,
    parameters: d,
    args: p4,
    argTypes: ae(u2),
    loaders: y2,
    beforeEach: m3,
    experimental_afterEach: g,
    globals: R4,
    ...S4 && { render: S4 },
    ...n3 && { userStoryFn: n3 },
    ...h && { play: h }
  };
}
s3(Se, "normalizeStory");
function je(r3, e2 = r3.title, t3) {
  let { id: o2, argTypes: n3 } = r3;
  return {
    id: D3(o2 || e2),
    ...r3,
    title: e2,
    ...n3 && { argTypes: ae(n3) },
    parameters: {
      fileName: t3,
      ...r3.parameters
    }
  };
}
s3(je, "normalizeComponentAnnotations");
var js = s3((r3) => {
  let { globals: e2, globalTypes: t3 } = r3;
  (e2 || t3) && s.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals: e2,
      globalTypes: t3
    })
  );
}, "checkGlobals");
var Ls = s3((r3) => {
  let { options: e2 } = r3;
  (e2 == null ? void 0 : e2.storySort) && s.error("The storySort option parameter can only be set globally");
}, "checkStorySort");
var Ze = s3((r3) => {
  r3 && (js(r3), Ls(r3));
}, "checkDisallowedParameters");
function yo(r3, e2, t3) {
  let { default: o2, __namedExportsOrder: n3, ...i } = r3, a2 = Object.values(i)[0];
  if (K3(a2)) {
    let d = je(a2.meta.input, t3, e2);
    Ze(d.parameters);
    let p4 = { meta: d, stories: {}, moduleExports: r3 };
    return Object.keys(i).forEach((u2) => {
      if (te(u2, d)) {
        let y2 = Se(u2, i[u2].input, d);
        Ze(y2.parameters), p4.stories[y2.id] = y2;
      }
    }), p4.projectAnnotations = a2.meta.preview.composed, p4;
  }
  let l = je(
    o2,
    t3,
    e2
  );
  Ze(l.parameters);
  let c = { meta: l, stories: {}, moduleExports: r3 };
  return Object.keys(i).forEach((d) => {
    if (te(d, l)) {
      let p4 = Se(d, i[d], l);
      Ze(p4.parameters), c.stories[p4.id] = p4;
    }
  }), c;
}
s3(yo, "processCSFFile");
function mo(r3) {
  return r3 != null && Ns(r3).includes("mount");
}
s3(mo, "mountDestructured");
function Ns(r3) {
  let e2 = r3.toString().match(/[^(]*\(([^)]*)/);
  if (!e2)
    return [];
  let t3 = ho(e2[1]);
  if (!t3.length)
    return [];
  let o2 = t3[0];
  return o2.startsWith("{") && o2.endsWith("}") ? ho(o2.slice(1, -1).replace(/\s/g, "")).map((i) => i.replace(/:.*|=.*/g, "")) : [];
}
s3(Ns, "getUsedProps");
function ho(r3) {
  let e2 = [], t3 = [], o2 = 0;
  for (let i = 0; i < r3.length; i++)
    if (r3[i] === "{" || r3[i] === "[")
      t3.push(r3[i] === "{" ? "}" : "]");
    else if (r3[i] === t3[t3.length - 1])
      t3.pop();
    else if (!t3.length && r3[i] === ",") {
      let a2 = r3.substring(o2, i).trim();
      a2 && e2.push(a2), o2 = i + 1;
    }
  let n3 = r3.substring(o2).trim();
  return n3 && e2.push(n3), e2;
}
s3(ho, "splitByComma");
function go(r3, e2, t3) {
  let o2 = t3(r3);
  return (n3) => e2(o2, n3);
}
s3(go, "decorateStory");
function So({
  componentId: r3,
  title: e2,
  kind: t3,
  id: o2,
  name: n3,
  story: i,
  parameters: a2,
  initialArgs: l,
  argTypes: c,
  ...d
} = {}) {
  return d;
}
s3(So, "sanitizeStoryContextUpdate");
function Hr(r3, e2) {
  let t3 = {}, o2 = s3((i) => (a2) => {
    if (!t3.value)
      throw new Error("Decorated function called without init");
    return t3.value = {
      ...t3.value,
      ...So(a2)
    }, i(t3.value);
  }, "bindWithContext"), n3 = e2.reduce(
    (i, a2) => go(i, a2, o2),
    r3
  );
  return (i) => (t3.value = i, n3(i));
}
s3(Hr, "defaultDecorateStory");
var M2 = s3((...r3) => {
  let e2 = {}, t3 = r3.filter(Boolean), o2 = t3.reduce((n3, i) => (Object.entries(i).forEach(([a2, l]) => {
    let c = n3[a2];
    Array.isArray(l) || typeof c > "u" ? n3[a2] = l : L4(l) && L4(c) ? e2[a2] = true : typeof l < "u" && (n3[a2] = l);
  }), n3), {});
  return Object.keys(e2).forEach((n3) => {
    let i = t3.filter(Boolean).map((a2) => a2[n3]).filter((a2) => typeof a2 < "u");
    i.every((a2) => L4(a2)) ? o2[n3] = M2(...i) : o2[n3] = i[i.length - 1];
  }), o2;
}, "combineParameters");
function Le(r3, e2, t3) {
  let { moduleExport: o2, id: n3, name: i } = r3 || {}, a2 = bo(
    r3,
    e2,
    t3
  ), l = s3(async (w5) => {
    let A3 = {};
    for (let O4 of [
      ..."__STORYBOOK_TEST_LOADERS__" in I5 && Array.isArray(I5.__STORYBOOK_TEST_LOADERS__) ? [I5.__STORYBOOK_TEST_LOADERS__] : [],
      F2(t3.loaders),
      F2(e2.loaders),
      F2(r3.loaders)
    ]) {
      if (w5.abortSignal.aborted)
        return A3;
      let N4 = await Promise.all(O4.map((U4) => U4(w5)));
      Object.assign(A3, ...N4);
    }
    return A3;
  }, "applyLoaders"), c = s3(async (w5) => {
    let A3 = new Array();
    for (let O4 of [
      ...F2(t3.beforeEach),
      ...F2(e2.beforeEach),
      ...F2(r3.beforeEach)
    ]) {
      if (w5.abortSignal.aborted)
        return A3;
      let N4 = await O4(w5);
      N4 && A3.push(N4);
    }
    return A3;
  }, "applyBeforeEach"), d = s3(async (w5) => {
    let A3 = [
      ...F2(t3.experimental_afterEach),
      ...F2(e2.experimental_afterEach),
      ...F2(r3.experimental_afterEach)
    ].reverse();
    for (let O4 of A3) {
      if (w5.abortSignal.aborted)
        return;
      await O4(w5);
    }
  }, "applyAfterEach"), p4 = s3((w5) => w5.originalStoryFn(w5.args, w5), "undecoratedStoryFn"), { applyDecorators: u2 = Hr, runStep: y2 } = t3, m3 = [
    ...F2(r3 == null ? void 0 : r3.decorators),
    ...F2(e2 == null ? void 0 : e2.decorators),
    ...F2(t3 == null ? void 0 : t3.decorators)
  ], g = (r3 == null ? void 0 : r3.userStoryFn) || (r3 == null ? void 0 : r3.render) || e2.render || t3.render, S4 = vr(u2)(p4, m3), h = s3((w5) => S4(w5), "unboundStoryFn"), E2 = (r3 == null ? void 0 : r3.play) ?? (e2 == null ? void 0 : e2.play), R4 = mo(E2);
  if (!g && !R4)
    throw new q2({ id: n3 });
  let f5 = s3((w5) => async () => (await w5.renderToCanvas(), w5.canvas), "defaultMount"), b5 = r3.mount ?? e2.mount ?? t3.mount ?? f5, x5 = t3.testingLibraryRender;
  return {
    storyGlobals: {},
    ...a2,
    moduleExport: o2,
    id: n3,
    name: i,
    story: i,
    originalStoryFn: g,
    undecoratedStoryFn: p4,
    unboundStoryFn: h,
    applyLoaders: l,
    applyBeforeEach: c,
    applyAfterEach: d,
    playFunction: E2,
    runStep: y2,
    mount: b5,
    testingLibraryRender: x5,
    renderToCanvas: t3.renderToCanvas,
    usesMount: R4
  };
}
s3(Le, "prepareStory");
function Wr(r3, e2, t3) {
  return {
    ...bo(void 0, r3, e2),
    moduleExport: t3
  };
}
s3(Wr, "prepareMeta");
function bo(r3, e2, t3) {
  var _a;
  let o2 = ["dev", "test"], n3 = ((_a = I5.DOCS_OPTIONS) == null ? void 0 : _a.autodocs) === true ? ["autodocs"] : [], i = oe2(
    ...o2,
    ...n3,
    ...t3.tags ?? [],
    ...e2.tags ?? [],
    ...(r3 == null ? void 0 : r3.tags) ?? []
  ), a2 = M2(
    t3.parameters,
    e2.parameters,
    r3 == null ? void 0 : r3.parameters
  ), { argTypesEnhancers: l = [], argsEnhancers: c = [] } = t3, d = M2(
    t3.argTypes,
    e2.argTypes,
    r3 == null ? void 0 : r3.argTypes
  );
  if (r3) {
    let E2 = (r3 == null ? void 0 : r3.userStoryFn) || (r3 == null ? void 0 : r3.render) || e2.render || t3.render;
    a2.__isArgsStory = E2 && E2.length > 0;
  }
  let p4 = {
    ...t3.args,
    ...e2.args,
    ...r3 == null ? void 0 : r3.args
  }, u2 = {
    ...e2.globals,
    ...r3 == null ? void 0 : r3.globals
  }, y2 = {
    componentId: e2.id,
    title: e2.title,
    kind: e2.title,
    // Back compat
    id: (r3 == null ? void 0 : r3.id) || e2.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: (r3 == null ? void 0 : r3.name) || "__meta",
    story: (r3 == null ? void 0 : r3.name) || "__meta",
    // Back compat
    component: e2.component,
    subcomponents: e2.subcomponents,
    tags: i,
    parameters: a2,
    initialArgs: p4,
    argTypes: d,
    storyGlobals: u2
  };
  y2.argTypes = l.reduce(
    (E2, R4) => R4({ ...y2, argTypes: E2 }),
    y2.argTypes
  );
  let m3 = { ...p4 };
  y2.initialArgs = c.reduce(
    (E2, R4) => ({
      ...E2,
      ...R4({
        ...y2,
        initialArgs: E2
      })
    }),
    m3
  );
  let { name: g, story: S4, ...h } = y2;
  return h;
}
s3(bo, "preparePartialAnnotations");
function er(r3) {
  var _a;
  let { args: e2 } = r3, t3 = {
    ...r3,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if ((_a = I5.FEATURES) == null ? void 0 : _a.argTypeTargetsV7) {
    let i = co(r3);
    t3 = {
      ...r3,
      allArgs: r3.args,
      argsByTarget: i,
      args: i[Gr] || {}
    };
  }
  let o2 = Object.entries(t3.args).reduce((i, [a2, l]) => {
    var _a2;
    if (!((_a2 = t3.argTypes[a2]) == null ? void 0 : _a2.mapping))
      return i[a2] = l, i;
    let c = s3((d) => {
      let p4 = t3.argTypes[a2].mapping;
      return p4 && d in p4 ? p4[d] : d;
    }, "mappingFn");
    return i[a2] = Array.isArray(l) ? l.map(c) : c(l), i;
  }, {}), n3 = Object.entries(o2).reduce((i, [a2, l]) => {
    let c = t3.argTypes[a2] || {};
    return z3(c, o2, t3.globals) && (i[a2] = l), i;
  }, {});
  return { ...t3, unmappedArgs: e2, args: n3 };
}
s3(er, "prepareContext");
var $r = s3((r3, e2, t3) => {
  let o2 = typeof r3;
  switch (o2) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: o2 };
    default:
      break;
  }
  return r3 ? t3.has(r3) ? (s.warn(P5`
        We've detected a cycle in arg '${e2}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (t3.add(r3), Array.isArray(r3) ? { name: "array", value: r3.length > 0 ? $r(r3[0], e2, new Set(
    t3
  )) : { name: "other", value: "unknown" } } : { name: "object", value: G2(r3, (i) => $r(i, e2, new Set(t3))) }) : { name: "object", value: {} };
}, "inferType");
var Yr = s3((r3) => {
  let { id: e2, argTypes: t3 = {}, initialArgs: o2 = {} } = r3, n3 = G2(o2, (a2, l) => ({
    name: l,
    type: $r(a2, `${e2}.${l}`, /* @__PURE__ */ new Set())
  })), i = G2(t3, (a2, l) => ({
    name: l
  }));
  return M2(n3, i, t3);
}, "inferArgTypes");
Yr.secondPass = true;
var To = s3((r3, e2) => Array.isArray(e2) ? e2.includes(r3) : r3.match(e2), "matches");
var rr = s3((r3, e2, t3) => !e2 && !t3 ? r3 : r3 && Dr(r3, (o2, n3) => {
  let i = o2.name || n3.toString();
  return !!(!e2 || To(i, e2)) && (!t3 || !To(i, t3));
}), "filterArgTypes");
var Bs = s3((r3, e2, t3) => {
  let { type: o2, options: n3 } = r3;
  if (o2) {
    if (t3.color && t3.color.test(e2)) {
      let i = o2.name;
      if (i === "string")
        return { control: { type: "color" } };
      i !== "enum" && s.warn(
        `Addon controls: Control of type color only supports string, received "${i}" instead`
      );
    }
    if (t3.date && t3.date.test(e2))
      return { control: { type: "date" } };
    switch (o2.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value: i } = o2;
        return { control: { type: (i == null ? void 0 : i.length) <= 5 ? "radio" : "select" }, options: i };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: n3 ? "select" : "object" } };
    }
  }
}, "inferControl");
var Ne = s3((r3) => {
  let {
    argTypes: e2,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    parameters: { __isArgsStory: t3, controls: { include: o2 = null, exclude: n3 = null, matchers: i = {} } = {} }
  } = r3;
  if (!t3)
    return e2;
  let a2 = rr(e2, o2, n3), l = G2(a2, (c, d) => (c == null ? void 0 : c.type) && Bs(c, d.toString(), i));
  return M2(l, a2);
}, "inferControls");
Ne.secondPass = true;
function be({
  argTypes: r3,
  globalTypes: e2,
  argTypesEnhancers: t3,
  decorators: o2,
  loaders: n3,
  beforeEach: i,
  experimental_afterEach: a2,
  globals: l,
  initialGlobals: c,
  ...d
}) {
  return l && Object.keys(l).length > 0 && m(P5`
      The preview.js 'globals' field is deprecated and will be removed in Storybook 9.0.
      Please use 'initialGlobals' instead. Learn more:

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#previewjs-globals-renamed-to-initialglobals
    `), {
    ...r3 && { argTypes: ae(r3) },
    ...e2 && { globalTypes: ae(e2) },
    decorators: F2(o2),
    loaders: F2(n3),
    beforeEach: F2(i),
    experimental_afterEach: F2(a2),
    argTypesEnhancers: [
      ...t3 || [],
      Yr,
      // inferControls technically should only run if the user is using the controls addon,
      // and so should be added by a preset there. However, as it seems some code relies on controls
      // annotations (in particular the angular implementation's `cleanArgsDecorator`), for backwards
      // compatibility reasons, we will leave this in the store until 7.0
      Ne
    ],
    initialGlobals: M2(c, l),
    ...d
  };
}
s3(be, "normalizeProjectAnnotations");
var Eo = s3((r3) => async () => {
  let e2 = [];
  for (let t3 of r3) {
    let o2 = await t3();
    o2 && e2.unshift(o2);
  }
  return async () => {
    for (let t3 of e2)
      await t3();
  };
}, "composeBeforeAllHooks");
function Kr(r3) {
  return async (e2, t3, o2) => {
    await r3.reduceRight(
      (i, a2) => async () => a2(e2, i, o2),
      async () => t3(o2)
    )();
  };
}
s3(Kr, "composeStepRunners");
function _e(r3, e2) {
  return r3.map((t3) => {
    var _a;
    return ((_a = t3.default) == null ? void 0 : _a[e2]) ?? t3[e2];
  }).filter(Boolean);
}
s3(_e, "getField");
function Q2(r3, e2, t3 = {}) {
  return _e(r3, e2).reduce((o2, n3) => {
    let i = F2(n3);
    return t3.reverseFileOrder ? [...i, ...o2] : [...o2, ...i];
  }, []);
}
s3(Q2, "getArrayField");
function Me(r3, e2) {
  return Object.assign({}, ..._e(r3, e2));
}
s3(Me, "getObjectField");
function Te(r3, e2) {
  return _e(r3, e2).pop();
}
s3(Te, "getSingletonField");
function Ee(r3) {
  var _a;
  let e2 = Q2(r3, "argTypesEnhancers"), t3 = _e(r3, "runStep"), o2 = Q2(r3, "beforeAll");
  return {
    parameters: M2(..._e(r3, "parameters")),
    decorators: Q2(r3, "decorators", {
      reverseFileOrder: !(((_a = I5.FEATURES) == null ? void 0 : _a.legacyDecoratorFileOrder) ?? false)
    }),
    args: Me(r3, "args"),
    argsEnhancers: Q2(r3, "argsEnhancers"),
    argTypes: Me(r3, "argTypes"),
    argTypesEnhancers: [
      ...e2.filter((n3) => !n3.secondPass),
      ...e2.filter((n3) => n3.secondPass)
    ],
    globals: Me(r3, "globals"),
    initialGlobals: Me(r3, "initialGlobals"),
    globalTypes: Me(r3, "globalTypes"),
    loaders: Q2(r3, "loaders"),
    beforeAll: Eo(o2),
    beforeEach: Q2(r3, "beforeEach"),
    experimental_afterEach: Q2(r3, "experimental_afterEach"),
    render: Te(r3, "render"),
    renderToCanvas: Te(r3, "renderToCanvas"),
    renderToDOM: Te(r3, "renderToDOM"),
    // deprecated
    applyDecorators: Te(r3, "applyDecorators"),
    runStep: Kr(t3),
    tags: Q2(r3, "tags"),
    mount: Te(r3, "mount"),
    testingLibraryRender: Te(r3, "testingLibraryRender")
  };
}
s3(Ee, "composeConfigs");
var Xr = class Xr2 {
  constructor() {
    this.reports = [];
  }
  async addReport(e2) {
    this.reports.push(e2);
  }
};
s3(Xr, "ReporterAPI");
var le = Xr;
function Jr(r3, e2, t3) {
  return K3(r3) ? {
    story: r3.input,
    meta: r3.meta.input,
    preview: r3.meta.preview.composed
  } : { story: r3, meta: e2, preview: t3 };
}
s3(Jr, "getCsfFactoryAnnotations");
function $s(r3) {
  globalThis.defaultProjectAnnotations = r3;
}
s3($s, "setDefaultProjectAnnotations");
var Ys = "ComposedStory";
var Ks = "Unnamed Story";
function Xs(r3) {
  return r3 ? Ee([r3]) : {};
}
s3(Xs, "extractAnnotation");
function Js(r3) {
  let e2 = Array.isArray(r3) ? r3 : [r3];
  return globalThis.globalProjectAnnotations = Ee([
    globalThis.defaultProjectAnnotations ?? {},
    Ee(e2.map(Xs))
  ]), globalThis.globalProjectAnnotations ?? {};
}
s3(Js, "setProjectAnnotations");
var Z2 = [];
function Ro(r3, e2, t3, o2, n3) {
  var _a;
  if (r3 === void 0)
    throw new Error("Expected a story but received undefined.");
  e2.title = e2.title ?? Ys;
  let i = je(e2), a2 = n3 || r3.storyName || ((_a = r3.story) == null ? void 0 : _a.name) || r3.name || Ks, l = Se(
    a2,
    r3,
    i
  ), c = be(
    Ee([
      o2 ?? globalThis.globalProjectAnnotations ?? {},
      t3 ?? {}
    ])
  ), d = Le(
    l,
    i,
    c
  ), u2 = {
    // TODO: remove loading from globalTypes in 9.0
    ...Xe(c.globalTypes),
    ...c.initialGlobals,
    ...d.storyGlobals
  }, y2 = new le(), m3 = s3(() => {
    let f5 = er({
      hooks: new se2(),
      globals: u2,
      args: { ...d.initialArgs },
      viewMode: "story",
      reporting: y2,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: s3((b5, x5) => d.runStep(b5, x5, f5), "step"),
      canvasElement: null,
      canvas: {},
      globalTypes: c.globalTypes,
      ...d,
      context: null,
      mount: null
    });
    return f5.parameters.__isPortableStory = true, f5.context = f5, d.renderToCanvas && (f5.renderToCanvas = async () => {
      var _a2;
      let b5 = await ((_a2 = d.renderToCanvas) == null ? void 0 : _a2.call(
        d,
        {
          componentId: d.componentId,
          title: d.title,
          id: d.id,
          name: d.name,
          tags: d.tags,
          showMain: s3(() => {
          }, "showMain"),
          showError: s3((x5) => {
            throw new Error(`${x5.title}
${x5.description}`);
          }, "showError"),
          showException: s3((x5) => {
            throw x5;
          }, "showException"),
          forceRemount: true,
          storyContext: f5,
          storyFn: s3(() => d.unboundStoryFn(f5), "storyFn"),
          unboundStoryFn: d.unboundStoryFn
        },
        f5.canvasElement
      ));
      b5 && Z2.push(b5);
    }), f5.mount = d.mount(f5), f5;
  }, "initializeContext"), g, S4 = s3(async (f5) => {
    var _a2;
    let b5 = m3();
    return b5.canvasElement ?? (b5.canvasElement = (_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body), g && (b5.loaded = g.loaded), Object.assign(b5, f5), d.playFunction(b5);
  }, "play"), h = s3((f5) => {
    let b5 = m3();
    return Object.assign(b5, f5), ri(d, b5);
  }, "run"), E2 = d.playFunction ? S4 : void 0;
  return Object.assign(
    s3(function(b5) {
      let x5 = m3();
      return g && (x5.loaded = g.loaded), x5.args = {
        ...x5.initialArgs,
        ...b5
      }, d.unboundStoryFn(x5);
    }, "storyFn"),
    {
      id: d.id,
      storyName: a2,
      load: s3(async () => {
        for (let b5 of [...Z2].reverse())
          await b5();
        Z2.length = 0;
        let f5 = m3();
        f5.loaded = await d.applyLoaders(f5), Z2.push(...(await d.applyBeforeEach(f5)).filter(Boolean)), g = f5;
      }, "load"),
      globals: u2,
      args: d.initialArgs,
      parameters: d.parameters,
      argTypes: d.argTypes,
      play: E2,
      run: h,
      reporting: y2,
      tags: d.tags
    }
  );
}
s3(Ro, "composeStory");
var Qs = s3((r3, e2, t3, o2) => Ro(r3, e2, t3, {}, o2), "defaultComposeStory");
function Zs(r3, e2, t3 = Qs) {
  let { default: o2, __esModule: n3, __namedExportsOrder: i, ...a2 } = r3, l = o2;
  return Object.entries(a2).reduce(
    (d, [p4, u2]) => {
      let { story: y2, meta: m3 } = Jr(u2);
      return !l && m3 && (l = m3), te(p4, l) ? Object.assign(d, {
        [p4]: t3(y2, l, e2, p4)
      }) : d;
    },
    {}
  );
}
s3(Zs, "composeStories");
function ei(r3) {
  return r3.extend({
    mount: s3(async ({ mount: e2, page: t3 }, o2) => {
      await o2(async (n3, ...i) => {
        if (!("__pw_type" in n3) || "__pw_type" in n3 && n3.__pw_type !== "jsx")
          throw new Error(P5`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories-playwright
            `);
        await t3.evaluate(async (l) => {
          var _a, _b, _c;
          let c = await ((_a = globalThis.__pwUnwrapObject) == null ? void 0 : _a.call(globalThis, l));
          return (_c = (_b = "__pw_type" in c ? c.type : c) == null ? void 0 : _b.load) == null ? void 0 : _c.call(_b);
        }, n3);
        let a2 = await e2(n3, ...i);
        return await t3.evaluate(async (l) => {
          var _a, _b;
          let c = await ((_a = globalThis.__pwUnwrapObject) == null ? void 0 : _a.call(globalThis, l)), d = "__pw_type" in c ? c.type : c, p4 = document.querySelector("#root");
          return (_b = d == null ? void 0 : d.play) == null ? void 0 : _b.call(d, { canvasElement: p4 });
        }, n3), a2;
      });
    }, "mount")
  });
}
s3(ei, "createPlaywrightTest");
async function ri(r3, e2) {
  var _a, _b;
  for (let n3 of [...Z2].reverse())
    await n3();
  if (Z2.length = 0, !e2.canvasElement) {
    let n3 = document.createElement("div");
    (_b = (_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body) == null ? void 0 : _b.appendChild(n3), e2.canvasElement = n3, Z2.push(() => {
      var _a2, _b2, _c, _d;
      ((_b2 = (_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body) == null ? void 0 : _b2.contains(n3)) && ((_d = (_c = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _c.body) == null ? void 0 : _d.removeChild(n3));
    });
  }
  if (e2.loaded = await r3.applyLoaders(e2), e2.abortSignal.aborted)
    return;
  Z2.push(...(await r3.applyBeforeEach(e2)).filter(Boolean));
  let t3 = r3.playFunction, o2 = r3.usesMount;
  o2 || await e2.mount(), !e2.abortSignal.aborted && (t3 && (o2 || (e2.mount = async () => {
    throw new J({ playFunction: t3.toString() });
  }), await t3(e2)), await r3.applyAfterEach(e2));
}
s3(ri, "runStory");
function wo(r3, e2) {
  return Ir(Or(r3, e2), (t3) => t3 === void 0);
}
s3(wo, "picky");
var vo = 1e3;
var ni = 1e4;
var Qr = class Qr2 {
  constructor(e2, t3, o2) {
    this.importFn = t3;
    this.getStoriesJsonData = s3(() => {
      let e3 = this.getSetStoriesPayload(), t4 = ["fileName", "docsOnly", "framework", "__id", "__isArgsStory"];
      return {
        v: 3,
        stories: G2(e3.stories, (n4) => {
          let { importPath: i2 } = this.storyIndex.entries[n4.id];
          return {
            ...wo(n4, ["id", "name", "title"]),
            importPath: i2,
            // These 3 fields were going to be dropped in v7, but instead we will keep them for the
            // 7.x cycle so that v7 Storybooks can be composed successfully in v6 Storybook.
            // In v8 we will (likely) completely drop support for `extract` and `getStoriesJsonData`
            kind: n4.title,
            story: n4.name,
            parameters: {
              ...wo(n4.parameters, t4),
              fileName: i2
            }
          };
        })
      };
    }, "getStoriesJsonData");
    this.storyIndex = new Qe(e2), this.projectAnnotations = be(o2);
    let { initialGlobals: n3, globalTypes: i } = this.projectAnnotations;
    this.args = new Ke(), this.userGlobals = new Je({ globals: n3, globalTypes: i }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, tr.default)(vo)(yo), this.prepareMetaWithCache = (0, tr.default)(vo)(Wr), this.prepareStoryWithCache = (0, tr.default)(ni)(Le);
  }
  setProjectAnnotations(e2) {
    this.projectAnnotations = be(e2);
    let { initialGlobals: t3, globalTypes: o2 } = e2;
    this.userGlobals.set({ globals: t3, globalTypes: o2 });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn: e2,
    storyIndex: t3
  }) {
    e2 && (this.importFn = e2), t3 && (this.storyIndex.entries = t3.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(e2) {
    return this.storyIndex.storyIdToEntry(e2);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(e2) {
    let { importPath: t3, title: o2 } = this.storyIndex.storyIdToEntry(e2), n3 = await this.importFn(t3);
    return this.processCSFFileWithCache(n3, t3, o2);
  }
  async loadAllCSFFiles() {
    let e2 = {};
    return Object.entries(this.storyIndex.entries).forEach(([o2, { importPath: n3 }]) => {
      e2[n3] = o2;
    }), (await Promise.all(
      Object.entries(e2).map(async ([o2, n3]) => ({
        importPath: o2,
        csfFile: await this.loadCSFFileByStoryId(n3)
      }))
    )).reduce(
      (o2, { importPath: n3, csfFile: i }) => (o2[n3] = i, o2),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile: e2 }) {
    let t3 = e2.meta;
    return this.prepareMetaWithCache(
      t3,
      this.projectAnnotations,
      e2.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId: e2 }) {
    let t3 = await this.loadCSFFileByStoryId(e2);
    return this.storyFromCSFFile({ storyId: e2, csfFile: t3 });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId: e2,
    csfFile: t3
  }) {
    let o2 = t3.stories[e2];
    if (!o2)
      throw new X2({ storyId: e2 });
    let n3 = t3.meta, i = this.prepareStoryWithCache(
      o2,
      n3,
      t3.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(i), this.hooks[i.id] = this.hooks[i.id] || new se2(), i;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile: e2
  }) {
    return Object.keys(this.storyIndex.entries).filter((t3) => !!e2.stories[t3]).map((t3) => this.storyFromCSFFile({ storyId: t3, csfFile: e2 }));
  }
  async loadEntry(e2) {
    let t3 = await this.storyIdToEntry(e2), o2 = t3.type === "docs" ? t3.storiesImports : [], [n3, ...i] = await Promise.all([
      this.importFn(t3.importPath),
      ...o2.map((a2) => {
        let l = this.storyIndex.importPathToEntry(a2);
        return this.loadCSFFileByStoryId(l.id);
      })
    ]);
    return { entryExports: n3, csfFiles: i };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separtely to the (immutable) story.
  getStoryContext(e2, { forceInitialArgs: t3 = false } = {}) {
    let o2 = this.userGlobals.get(), { initialGlobals: n3 } = this.userGlobals, i = new le();
    return er({
      ...e2,
      args: t3 ? e2.initialArgs : this.args.get(e2.id),
      initialGlobals: n3,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals: o2,
      reporting: i,
      globals: {
        ...o2,
        ...e2.storyGlobals
      },
      hooks: this.hooks[e2.id]
    });
  }
  addCleanupCallbacks(e2, t3) {
    this.cleanupCallbacks[e2.id] = t3;
  }
  async cleanupStory(e2) {
    this.hooks[e2.id].clean();
    let t3 = this.cleanupCallbacks[e2.id];
    if (t3)
      for (let o2 of [...t3].reverse())
        await o2();
    delete this.cleanupCallbacks[e2.id];
  }
  extract(e2 = { includeDocsOnly: false }) {
    let { cachedCSFFiles: t3 } = this;
    if (!t3)
      throw new L2();
    return Object.entries(this.storyIndex.entries).reduce(
      (o2, [n3, { type: i, importPath: a2 }]) => {
        if (i === "docs")
          return o2;
        let l = t3[a2], c = this.storyFromCSFFile({ storyId: n3, csfFile: l });
        return !e2.includeDocsOnly && c.parameters.docsOnly || (o2[n3] = Object.entries(c).reduce(
          (d, [p4, u2]) => p4 === "moduleExport" || typeof u2 == "function" ? d : Array.isArray(u2) ? Object.assign(d, { [p4]: u2.slice().sort() }) : Object.assign(d, { [p4]: u2 }),
          {
            //
            args: c.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...c.storyGlobals
            }
          }
        )), o2;
      },
      {}
    );
  }
  // TODO: Remove in 9.0
  getSetStoriesPayload() {
    let e2 = this.extract({ includeDocsOnly: true }), t3 = Object.values(e2).reduce(
      (o2, { title: n3 }) => (o2[n3] = {}, o2),
      {}
    );
    return {
      v: 2,
      globals: this.userGlobals.get(),
      globalParameters: {},
      kindParameters: t3,
      stories: e2
    };
  }
  raw() {
    return m(
      "StoryStore.raw() is deprecated and will be removed in 9.0, please use extract() instead"
    ), Object.values(this.extract()).map(({ id: e2 }) => this.fromId(e2)).filter(Boolean);
  }
  fromId(e2) {
    if (m(
      "StoryStore.fromId() is deprecated and will be removed in 9.0, please use loadStory() instead"
    ), !this.cachedCSFFiles)
      throw new Error("Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.");
    let t3;
    try {
      ({ importPath: t3 } = this.storyIndex.storyIdToEntry(e2));
    } catch {
      return null;
    }
    let o2 = this.cachedCSFFiles[t3], n3 = this.storyFromCSFFile({ storyId: e2, csfFile: o2 });
    return {
      ...n3,
      storyFn: s3((i) => {
        let a2 = {
          ...this.getStoryContext(n3),
          abortSignal: new AbortController().signal,
          canvasElement: null,
          loaded: {},
          step: s3((l, c) => n3.runStep(l, c, a2), "step"),
          context: null,
          mount: null,
          canvas: {},
          viewMode: "story"
        };
        return n3.unboundStoryFn({ ...a2, ...i });
      }, "storyFn")
    };
  }
};
s3(Qr, "StoryStore");
var Re = Qr;
function Zr(r3) {
  return r3.startsWith("\\\\?\\") ? r3 : r3.replace(/\\/g, "/");
}
s3(Zr, "slash");
var ii = s3((r3) => {
  if (r3.length === 0)
    return r3;
  let e2 = r3[r3.length - 1], t3 = e2 == null ? void 0 : e2.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (r3.length === 1)
    return [t3];
  let o2 = r3[r3.length - 2];
  return t3 && o2 && t3.toLowerCase() === o2.toLowerCase() ? [...r3.slice(0, -2), t3] : t3 && (/^(story|stories)([.][^.]+)$/i.test(e2) || /^index$/i.test(t3)) ? r3.slice(0, -1) : [...r3.slice(0, -1), t3];
}, "sanitize");
function Ao(r3) {
  return r3.flatMap((e2) => e2.split("/")).filter(Boolean).join("/");
}
s3(Ao, "pathJoin");
var Co = s3((r3, e2, t3) => {
  let { directory: o2, importPathMatcher: n3, titlePrefix: i = "" } = e2 || {};
  typeof r3 == "number" && n.warn(P5`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let a2 = Zr(String(r3));
  if (n3.exec(a2)) {
    if (!t3) {
      let l = a2.replace(o2, ""), c = Ao([i, l]).split("/");
      return c = ii(c), c.join("/");
    }
    return i ? Ao([i, t3]) : t3;
  }
}, "userOrAutoTitleFromSpecifier");
var ai = s3((r3, e2, t3) => {
  for (let o2 = 0; o2 < e2.length; o2 += 1) {
    let n3 = Co(r3, e2[o2], t3);
    if (n3)
      return n3;
  }
  return t3 || void 0;
}, "userOrAutoTitle");
var Po = /\s*\/\s*/;
var Fo = s3((r3 = {}) => (e2, t3) => {
  if (e2.title === t3.title && !r3.includeNames)
    return 0;
  let o2 = r3.method || "configure", n3 = r3.order || [], i = e2.title.trim().split(Po), a2 = t3.title.trim().split(Po);
  r3.includeNames && (i.push(e2.name), a2.push(t3.name));
  let l = 0;
  for (; i[l] || a2[l]; ) {
    if (!i[l])
      return -1;
    if (!a2[l])
      return 1;
    let c = i[l], d = a2[l];
    if (c !== d) {
      let u2 = n3.indexOf(c), y2 = n3.indexOf(d), m3 = n3.indexOf("*");
      return u2 !== -1 || y2 !== -1 ? (u2 === -1 && (m3 !== -1 ? u2 = m3 : u2 = n3.length), y2 === -1 && (m3 !== -1 ? y2 = m3 : y2 = n3.length), u2 - y2) : o2 === "configure" ? 0 : c.localeCompare(d, r3.locales ? r3.locales : void 0, {
        numeric: true,
        sensitivity: "accent"
      });
    }
    let p4 = n3.indexOf(c);
    p4 === -1 && (p4 = n3.indexOf("*")), n3 = p4 !== -1 && Array.isArray(n3[p4 + 1]) ? n3[p4 + 1] : [], l += 1;
  }
  return 0;
}, "storySort");
var li = s3((r3, e2, t3) => {
  if (e2) {
    let o2;
    typeof e2 == "function" ? o2 = e2 : o2 = Fo(e2), r3.sort(o2);
  } else
    r3.sort(
      (o2, n3) => t3.indexOf(o2.importPath) - t3.indexOf(n3.importPath)
    );
  return r3;
}, "sortStoriesCommon");
var ci = s3((r3, e2, t3) => {
  try {
    return li(r3, e2, t3);
  } catch (o2) {
    throw new Error(P5`
    Error sorting stories with sort parameter ${e2}:

    > ${o2.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
}, "sortStoriesV7");
var ee3 = new Error("prepareAborted");
var { AbortController: Do } = globalThis;
function ko(r3) {
  try {
    let { name: e2 = "Error", message: t3 = String(r3), stack: o2 } = r3;
    return { name: e2, message: t3, stack: o2 };
  } catch {
    return { name: "Error", message: String(r3) };
  }
}
s3(ko, "serializeError");
var et = class et2 {
  constructor(e2, t3, o2, n3, i, a2, l = { autoplay: true, forceInitialArgs: false }, c) {
    this.channel = e2;
    this.store = t3;
    this.renderToScreen = o2;
    this.callbacks = n3;
    this.id = i;
    this.viewMode = a2;
    this.renderOptions = l;
    this.type = "story";
    this.notYetRendered = true;
    this.rerenderEnqueued = false;
    this.disableKeyListeners = false;
    this.teardownRender = s3(() => {
    }, "teardownRender");
    this.torndown = false;
    this.abortController = new Do(), c && (this.story = c, this.phase = "preparing");
  }
  async runPhase(e2, t3, o2) {
    this.phase = t3, this.channel.emit(B, { newPhase: this.phase, storyId: this.id }), o2 && (await o2(), this.checkIfAborted(e2));
  }
  checkIfAborted(e2) {
    return e2.aborted ? (this.phase = "aborted", this.channel.emit(B, { newPhase: this.phase, storyId: this.id }), true) : false;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), ee3;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(e2) {
    return !!(this.id === e2.id && this.story && this.story === e2.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(e2) {
    return this.canvasElement = e2, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    let { forceInitialArgs: e2 } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: e2 });
  }
  async render({
    initial: e2 = false,
    forceRemount: t3 = false
  } = {}) {
    var _a, _b, _c, _d;
    let { canvasElement: o2 } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    let n3 = this.story;
    if (!o2)
      throw new Error("cannot render when canvasElement is unset");
    let {
      id: i,
      componentId: a2,
      title: l,
      name: c,
      tags: d,
      applyLoaders: p4,
      applyBeforeEach: u2,
      applyAfterEach: y2,
      unboundStoryFn: m3,
      playFunction: g,
      runStep: S4
    } = n3;
    t3 && !e2 && (this.cancelRender(), this.abortController = new Do());
    let h = this.abortController.signal, E2 = false, R4 = n3.usesMount;
    try {
      let f5 = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: h,
        canvasElement: o2,
        loaded: {},
        step: s3((C3, z4) => S4(C3, z4, f5), "step"),
        context: null,
        canvas: {},
        renderToCanvas: s3(async () => {
          let C3 = await this.renderToScreen(b5, o2);
          this.teardownRender = C3 || (() => {
          }), E2 = true;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: s3(async (...C3) => {
          var _a2, _b2;
          (_b2 = (_a2 = this.callbacks).showStoryDuringRender) == null ? void 0 : _b2.call(_a2);
          let z4 = null;
          return await this.runPhase(h, "rendering", async () => {
            z4 = await n3.mount(f5)(...C3);
          }), R4 && await this.runPhase(h, "playing"), z4;
        }, "mount")
      };
      f5.context = f5;
      let b5 = {
        componentId: a2,
        title: l,
        kind: l,
        id: i,
        name: c,
        story: c,
        tags: d,
        ...this.callbacks,
        showError: s3((C3) => (this.phase = "errored", this.callbacks.showError(C3)), "showError"),
        showException: s3((C3) => (this.phase = "errored", this.callbacks.showException(C3)), "showException"),
        forceRemount: t3 || this.notYetRendered,
        storyContext: f5,
        storyFn: s3(() => m3(f5), "storyFn"),
        unboundStoryFn: m3
      };
      if (await this.runPhase(h, "loading", async () => {
        f5.loaded = await p4(f5);
      }), h.aborted)
        return;
      let x5 = await u2(f5);
      if (this.store.addCleanupCallbacks(n3, x5), this.checkIfAborted(h) || (!E2 && !R4 && await f5.mount(), this.notYetRendered = false, h.aborted))
        return;
      let w5 = ((_b = (_a = this.story.parameters) == null ? void 0 : _a.test) == null ? void 0 : _b.dangerouslyIgnoreUnhandledErrors) === true, A3 = /* @__PURE__ */ new Set(), O4 = s3((C3) => A3.add("error" in C3 ? C3.error : C3.reason), "onError");
      if (this.renderOptions.autoplay && t3 && g && this.phase !== "errored") {
        window.addEventListener("error", O4), window.addEventListener("unhandledrejection", O4), this.disableKeyListeners = true;
        try {
          if (R4 ? await g(f5) : (f5.mount = async () => {
            throw new J({ playFunction: g.toString() });
          }, await this.runPhase(h, "playing", async () => g(f5))), !E2)
            throw new z2();
          this.checkIfAborted(h), !w5 && A3.size > 0 ? await this.runPhase(h, "errored") : await this.runPhase(h, "played");
        } catch (C3) {
          if ((_d = (_c = this.callbacks).showStoryDuringRender) == null ? void 0 : _d.call(_c), await this.runPhase(h, "errored", async () => {
            this.channel.emit(a, ko(C3));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw C3;
          console.error(C3);
        }
        if (!w5 && A3.size > 0 && this.channel.emit(
          Y,
          Array.from(A3).map(ko)
        ), this.disableKeyListeners = false, window.removeEventListener("unhandledrejection", O4), window.removeEventListener("error", O4), h.aborted)
          return;
      }
      await this.runPhase(
        h,
        "completed",
        async () => this.channel.emit(X, i)
      ), this.phase !== "errored" && await this.runPhase(h, "afterEach", async () => {
        await y2(f5);
      });
      let N4 = !w5 && A3.size > 0, U4 = f5.reporting.reports.some(
        (C3) => C3.status === "failed"
      ), ye = N4 || U4;
      await this.runPhase(
        h,
        "finished",
        async () => this.channel.emit(q, {
          storyId: i,
          status: ye ? "error" : "success",
          reporters: f5.reporting.reports
        })
      );
    } catch (f5) {
      this.phase = "errored", this.callbacks.showException(f5), await this.runPhase(
        h,
        "finished",
        async () => this.channel.emit(q, {
          storyId: i,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = false, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = true;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: true });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let e2 = 0; e2 < 3; e2 += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((t3) => setTimeout(t3, 0));
    }
    window.location.reload(), await new Promise(() => {
    });
  }
};
s3(et, "StoryRender");
var ce = et;
var { fetch: Fi } = I5;
var Ii = "./index.json";
var rt = class rt2 {
  constructor(e2, t3, o2 = V4.getChannel(), n3 = true) {
    this.importFn = e2;
    this.getProjectAnnotations = t3;
    this.channel = o2;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((i, a2) => {
      this.resolveStoreInitializationPromise = i, this.rejectStoreInitializationPromise = a2;
    }), n3 && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: s3((e2, t3) => {
          if (this.storyStoreValue)
            return m("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[t3];
          throw new U2();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      let e2 = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(e2), await this.initializeWithProjectAnnotations(e2);
    } catch (e2) {
      this.rejectStoreInitializationPromise(e2);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(m2, this.onStoryIndexChanged.bind(this)), this.channel.on(k, this.onUpdateGlobals.bind(this)), this.channel.on(z, this.onUpdateArgs.bind(this)), this.channel.on(SE, this.onRequestArgTypesInfo.bind(this)), this.channel.on(W, this.onResetArgs.bind(this)), this.channel.on(L, this.onForceReRender.bind(this)), this.channel.on(P, this.onForceRemount.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      let e2 = await this.getProjectAnnotations();
      if (this.renderToCanvas = e2.renderToCanvas, !this.renderToCanvas)
        throw new G();
      return e2;
    } catch (e2) {
      throw this.renderPreviewEntryError("Error reading preview.js:", e2), e2;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(e2) {
    this.projectAnnotationsBeforeInitialization = e2;
    try {
      let t3 = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(t3);
    } catch (t3) {
      throw this.renderPreviewEntryError("Error loading story index:", t3), t3;
    }
  }
  async runBeforeAllHook(e2) {
    var _a, _b;
    try {
      await ((_a = this.beforeAllCleanup) == null ? void 0 : _a.call(this)), this.beforeAllCleanup = await ((_b = e2.beforeAll) == null ? void 0 : _b.call(e2));
    } catch (t3) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", t3), t3;
    }
  }
  async getStoryIndexFromServer() {
    let e2 = await Fi(Ii);
    if (e2.status === 200)
      return e2.json();
    throw new M({ text: await e2.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(e2) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new Re(
      e2,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "emitGlobals" });
    let e2 = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(u, e2);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: e2
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = e2;
    let t3 = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(t3), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(t3);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(t3), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        let e2 = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(e2);
          return;
        }
        await this.onStoriesChanged({ storyIndex: e2 });
      } catch (e2) {
        throw this.renderPreviewEntryError("Error loading story index:", e2), e2;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: e2,
    storyIndex: t3
  }) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn: e2, storyIndex: t3 });
  }
  async onUpdateGlobals({
    globals: e2,
    currentStory: t3
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new Y2({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(e2), t3) {
      let { initialGlobals: o2, storyGlobals: n3, userGlobals: i, globals: a2 } = this.storyStoreValue.getStoryContext(t3);
      this.channel.emit(U, {
        initialGlobals: o2,
        userGlobals: i,
        storyGlobals: n3,
        globals: a2
      });
    } else {
      let { initialGlobals: o2, globals: n3 } = this.storyStoreValue.userGlobals;
      this.channel.emit(U, {
        initialGlobals: o2,
        userGlobals: n3,
        storyGlobals: {},
        globals: n3
      });
    }
    await Promise.all(this.storyRenders.map((o2) => o2.rerender()));
  }
  async onUpdateArgs({ storyId: e2, updatedArgs: t3 }) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(e2, t3), await Promise.all(
      this.storyRenders.filter((o2) => o2.id === e2 && !o2.renderOptions.forceInitialArgs).map(
        (o2) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          o2.story && o2.story.usesMount ? o2.remount() : o2.rerender()
        )
      )
    ), this.channel.emit(f, {
      storyId: e2,
      args: this.storyStoreValue.args.get(e2)
    });
  }
  async onRequestArgTypesInfo({ id: e2, payload: t3 }) {
    var _a;
    try {
      await this.storeInitializationPromise;
      let o2 = await ((_a = this.storyStoreValue) == null ? void 0 : _a.loadStory(t3));
      this.channel.emit(TE, {
        id: e2,
        success: true,
        payload: { argTypes: (o2 == null ? void 0 : o2.argTypes) || {} },
        error: null
      });
    } catch (o2) {
      this.channel.emit(TE, {
        id: e2,
        success: false,
        error: o2 == null ? void 0 : o2.message
      });
    }
  }
  async onResetArgs({ storyId: e2, argNames: t3 }) {
    var _a;
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "onResetArgs" });
    let n3 = ((_a = this.storyRenders.find((l) => l.id === e2)) == null ? void 0 : _a.story) || await this.storyStoreValue.loadStory({ storyId: e2 }), a2 = (t3 || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(n3.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(e2))
      ])
    ]).reduce((l, c) => (l[c] = n3.initialArgs[c], l), {});
    await this.onUpdateArgs({ storyId: e2, updatedArgs: a2 });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((e2) => e2.rerender()));
  }
  async onForceRemount({ storyId: e2 }) {
    await Promise.all(this.storyRenders.filter((t3) => t3.id === e2).map((t3) => t3.remount()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(e2, t3, o2, n3) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new Y2({
        methodName: "renderStoryToElement"
      });
    let i = new ce(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      o2,
      e2.id,
      "docs",
      n3,
      e2
    );
    return i.renderToElement(t3), this.storyRenders.push(i), async () => {
      await this.teardownRender(i);
    };
  }
  async teardownRender(e2, { viewModeChanged: t3 } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((o2) => o2 !== e2), await ((_a = e2 == null ? void 0 : e2.teardown) == null ? void 0 : _a.call(e2, { viewModeChanged: t3 }));
  }
  // API
  async loadStory({ storyId: e2 }) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId: e2 });
  }
  getStoryContext(e2, { forceInitialArgs: t3 = false } = {}) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(e2, { forceInitialArgs: t3 });
  }
  async extract(e2) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(e2);
  }
  // UTILITIES
  renderPreviewEntryError(e2, t3) {
    this.previewEntryError = t3, s.error(e2), s.error(t3), this.channel.emit(N, t3);
  }
};
s3(rt, "Preview");
var xe = rt;
var Oi = false;
var tt = "Invariant failed";
function or(r3, e2) {
  if (!r3) {
    if (Oi)
      throw new Error(tt);
    var t3 = typeof e2 == "function" ? e2() : e2, o2 = t3 ? "".concat(tt, ": ").concat(t3) : tt;
    throw new Error(o2);
  }
}
s3(or, "invariant");
var ot = class ot2 {
  constructor(e2, t3, o2, n3) {
    this.channel = e2;
    this.store = t3;
    this.renderStoryToElement = o2;
    this.storyIdByName = s3((e3) => {
      let t4 = this.nameToStoryId.get(e3);
      if (t4)
        return t4;
      throw new Error(`No story found with that name: ${e3}`);
    }, "storyIdByName");
    this.componentStories = s3(() => this.componentStoriesValue, "componentStories");
    this.componentStoriesFromCSFFile = s3((e3) => this.store.componentStoriesFromCSFFile({ csfFile: e3 }), "componentStoriesFromCSFFile");
    this.storyById = s3((e3) => {
      if (!e3) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      let t4 = this.storyIdToCSFFile.get(e3);
      if (!t4)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${e3}`);
      return this.store.storyFromCSFFile({ storyId: e3, csfFile: t4 });
    }, "storyById");
    this.getStoryContext = s3((e3) => ({
      ...this.store.getStoryContext(e3),
      loaded: {},
      viewMode: "docs"
    }), "getStoryContext");
    this.loadStory = s3((e3) => this.store.loadStory({ storyId: e3 }), "loadStory");
    this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), n3.forEach((i, a2) => {
      this.referenceCSFFile(i);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(e2) {
    this.exportsToCSFFile.set(e2.moduleExports, e2), this.exportsToCSFFile.set(e2.moduleExports.default, e2), this.store.componentStoriesFromCSFFile(
      { csfFile: e2 }
    ).forEach((o2) => {
      let n3 = e2.stories[o2.id];
      this.storyIdToCSFFile.set(n3.id, e2), this.exportToStory.set(n3.moduleExport, o2);
    });
  }
  attachCSFFile(e2) {
    if (!this.exportsToCSFFile.has(e2.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    if (this.attachedCSFFiles.has(e2))
      return;
    this.attachedCSFFiles.add(e2), this.store.componentStoriesFromCSFFile({ csfFile: e2 }).forEach((o2) => {
      this.nameToStoryId.set(o2.name, o2.id), this.componentStoriesValue.push(o2), this.primaryStory || (this.primaryStory = o2);
    });
  }
  referenceMeta(e2, t3) {
    let o2 = this.resolveModuleExport(e2);
    if (o2.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    t3 && this.attachCSFFile(o2.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations: e2 } = this.store;
    if (!e2)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return e2;
  }
  resolveAttachedModuleExportType(e2) {
    if (e2 === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    let t3 = Array.from(this.attachedCSFFiles)[0];
    if (e2 === "meta")
      return { type: "meta", csfFile: t3 };
    let { component: o2 } = t3.meta;
    if (!o2)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component: o2 };
  }
  resolveModuleExport(e2) {
    let t3 = this.exportsToCSFFile.get(e2);
    if (t3)
      return { type: "meta", csfFile: t3 };
    let o2 = this.exportToStory.get(
      K3(e2) ? e2.input : e2
    );
    return o2 ? { type: "story", story: o2 } : { type: "component", component: e2 };
  }
  resolveOf(e2, t3 = []) {
    let o2;
    if (["component", "meta", "story"].includes(e2)) {
      let n3 = e2;
      o2 = this.resolveAttachedModuleExportType(n3);
    } else
      o2 = this.resolveModuleExport(e2);
    if (t3.length && !t3.includes(o2.type)) {
      let n3 = o2.type === "component" ? "component or unknown" : o2.type;
      throw new Error(P5`Invalid value passed to the 'of' prop. The value was resolved to a '${n3}' type but the only types for this block are: ${t3.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (o2.type) {
      case "component":
        return {
          ...o2,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...o2,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: o2.csfFile })
        };
      case "story":
      default:
        return o2;
    }
  }
};
s3(ot, "DocsContext");
var re2 = ot;
var nt = class nt2 {
  constructor(e2, t3, o2, n3) {
    this.channel = e2;
    this.store = t3;
    this.entry = o2;
    this.callbacks = n3;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = o2.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e2, csfFiles: t3 = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw ee3;
    let { importPath: o2, title: n3 } = this.entry, i = this.store.processCSFFileWithCache(
      e2,
      o2,
      n3
    ), a2 = Object.keys(i.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: a2, csfFile: i }), this.csfFiles = [i, ...t3], this.preparing = false;
  }
  isEqual(e2) {
    return !!(this.id === e2.id && this.story && this.story === e2.story);
  }
  docsContext(e2) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let t3 = new re2(
      this.channel,
      this.store,
      e2,
      this.csfFiles
    );
    return this.csfFiles.forEach((o2) => t3.attachCSFFile(o2)), t3;
  }
  async renderToElement(e2, t3) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let o2 = this.docsContext(t3), { docs: n3 } = this.story.parameters || {};
    if (!n3)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let i = await n3.renderer(), { render: a2 } = i, l = s3(async () => {
      try {
        await a2(o2, n3, e2), this.channel.emit(I, this.id);
      } catch (c) {
        this.callbacks.showException(c);
      }
    }, "renderDocs");
    return this.rerender = async () => l(), this.teardownRender = async ({ viewModeChanged: c }) => {
      !c || !e2 || i.unmount(e2);
    }, l();
  }
  async teardown({ viewModeChanged: e2 } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged: e2 }), this.torndown = true;
  }
};
s3(nt, "CsfDocsRender");
var qe = nt;
var st = class st2 {
  constructor(e2, t3, o2, n3) {
    this.channel = e2;
    this.store = t3;
    this.entry = o2;
    this.callbacks = n3;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = o2.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e2, csfFiles: t3 = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw ee3;
    this.csfFiles = t3, this.exports = e2, this.preparing = false;
  }
  isEqual(e2) {
    return !!(this.id === e2.id && this.exports && this.exports === e2.exports);
  }
  docsContext(e2) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new re2(
      this.channel,
      this.store,
      e2,
      this.csfFiles
    );
  }
  async renderToElement(e2, t3) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let o2 = this.docsContext(t3), { docs: n3 } = this.store.projectAnnotations.parameters || {};
    if (!n3)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let i = { ...n3, page: this.exports.default }, a2 = await n3.renderer(), { render: l } = a2, c = s3(async () => {
      try {
        await l(o2, i, e2), this.channel.emit(I, this.id);
      } catch (d) {
        this.callbacks.showException(d);
      }
    }, "renderDocs");
    return this.rerender = async () => c(), this.teardownRender = async ({ viewModeChanged: d } = {}) => {
      !d || !e2 || (a2.unmount(e2), this.torndown = true);
    }, c();
  }
  async teardown({ viewModeChanged: e2 } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged: e2 }), this.torndown = true;
  }
};
s3(st, "MdxDocsRender");
var Ue = st;
var Ki = globalThis;
function Xi(r3) {
  let e2 = r3.composedPath && r3.composedPath()[0] || r3.target;
  return /input|textarea/i.test(e2.tagName) || e2.getAttribute("contenteditable") !== null;
}
s3(Xi, "focusInInput");
var Go = "attached-mdx";
var Ji = "unattached-mdx";
function Qi({ tags: r3 }) {
  return (r3 == null ? void 0 : r3.includes(Ji)) || (r3 == null ? void 0 : r3.includes(Go));
}
s3(Qi, "isMdxEntry");
function at(r3) {
  return r3.type === "story";
}
s3(at, "isStoryRender");
function Zi(r3) {
  return r3.type === "docs";
}
s3(Zi, "isDocsRender");
function ea(r3) {
  return Zi(r3) && r3.subtype === "csf";
}
s3(ea, "isCsfDocsRender");
var lt = class lt2 extends xe {
  constructor(t3, o2, n3, i) {
    super(t3, o2, void 0, false);
    this.importFn = t3;
    this.getProjectAnnotations = o2;
    this.selectionStore = n3;
    this.view = i;
    this.initialize();
  }
  setupListeners() {
    super.setupListeners(), Ki.onkeydown = this.onKeydown.bind(this), this.channel.on(p, this.onSetCurrentStory.bind(this)), this.channel.on(
      n2,
      this.onUpdateQueryParams.bind(this)
    ), this.channel.on(t, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "setInitialGlobals" });
    let { globals: t3 } = this.selectionStore.selectionSpecifier || {};
    t3 && this.storyStoreValue.userGlobals.updateFromPersisted(t3), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(t3) {
    return await super.initializeWithStoryIndex(t3), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new Y2({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier: t3, args: o2 } = this.selectionStore.selectionSpecifier, n3 = this.storyStoreValue.storyIndex.entryFromSpecifier(t3);
    if (!n3) {
      t3 === "*" ? this.renderStoryLoadingException(t3, new F()) : this.renderStoryLoadingException(
        t3,
        new K2({ storySpecifier: t3.toString() })
      );
      return;
    }
    let { id: i, type: a2 } = n3;
    this.selectionStore.setSelection({ storyId: i, viewMode: a2 }), this.channel.emit(b, this.selectionStore.selection), this.channel.emit(
      r,
      this.selectionStore.selection
    ), await this.renderSelection({ persistedArgs: o2 });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: t3
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: t3 }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: t3,
    storyIndex: o2
  }) {
    await super.onStoriesChanged({ importFn: t3, storyIndex: o2 }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(t3) {
    if (!this.storyRenders.find((o2) => o2.disableKeyListeners) && !Xi(t3)) {
      let { altKey: o2, ctrlKey: n3, metaKey: i, shiftKey: a2, key: l, code: c, keyCode: d } = t3;
      this.channel.emit(e, {
        event: { altKey: o2, ctrlKey: n3, metaKey: i, shiftKey: a2, key: l, code: c, keyCode: d }
      });
    }
  }
  async onSetCurrentStory(t3) {
    this.selectionStore.setSelection({ viewMode: "story", ...t3 }), await this.storeInitializationPromise, this.channel.emit(r, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(t3) {
    this.selectionStore.setQueryParams(t3);
  }
  async onUpdateGlobals({ globals: t3 }) {
    var _a, _b;
    let o2 = this.currentRender instanceof ce && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals: t3, currentStory: o2 }), (this.currentRender instanceof Ue || this.currentRender instanceof qe) && await ((_b = (_a = this.currentRender).rerender) == null ? void 0 : _b.call(_a));
  }
  async onUpdateArgs({ storyId: t3, updatedArgs: o2 }) {
    super.onUpdateArgs({ storyId: t3, updatedArgs: o2 });
  }
  async onPreloadStories({ ids: t3 }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(t3.map((o2) => {
      var _a;
      return (_a = this.storyStoreValue) == null ? void 0 : _a.loadEntry(o2);
    }));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs: t3 } = {}) {
    var _a, _b, _c, _d;
    let { renderToCanvas: o2 } = this;
    if (!this.storyStoreValue || !o2)
      throw new Y2({ methodName: "renderSelection" });
    let { selection: n3 } = this.selectionStore;
    if (!n3)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId: i } = n3, a2;
    try {
      a2 = await this.storyStoreValue.storyIdToEntry(i);
    } catch (m3) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(i, m3);
      return;
    }
    let l = ((_a = this.currentSelection) == null ? void 0 : _a.storyId) !== i, c = ((_b = this.currentRender) == null ? void 0 : _b.type) !== a2.type;
    a2.type === "story" ? this.view.showPreparingStory({ immediate: c }) : this.view.showPreparingDocs({ immediate: c }), ((_c = this.currentRender) == null ? void 0 : _c.isPreparing()) && await this.teardownRender(this.currentRender);
    let d;
    a2.type === "story" ? d = new ce(
      this.channel,
      this.storyStoreValue,
      o2,
      this.mainStoryCallbacks(i),
      i,
      "story"
    ) : Qi(a2) ? d = new Ue(
      this.channel,
      this.storyStoreValue,
      a2,
      this.mainStoryCallbacks(i)
    ) : d = new qe(
      this.channel,
      this.storyStoreValue,
      a2,
      this.mainStoryCallbacks(i)
    );
    let p4 = this.currentSelection;
    this.currentSelection = n3;
    let u2 = this.currentRender;
    this.currentRender = d;
    try {
      await d.prepare();
    } catch (m3) {
      u2 && await this.teardownRender(u2), m3 !== ee3 && this.renderStoryLoadingException(i, m3);
      return;
    }
    let y2 = !l && u2 && !d.isEqual(u2);
    if (t3 && at(d) && (or(!!d.story), this.storyStoreValue.args.updateFromPersisted(d.story, t3)), u2 && !u2.torndown && !l && !y2 && !c) {
      this.currentRender = u2, this.channel.emit(j, i), this.view.showMain();
      return;
    }
    if (u2 && await this.teardownRender(u2, { viewModeChanged: c }), p4 && (l || c) && this.channel.emit(Q, i), at(d)) {
      or(!!d.story);
      let {
        parameters: m3,
        initialArgs: g,
        argTypes: S4,
        unmappedArgs: h,
        initialGlobals: E2,
        userGlobals: R4,
        storyGlobals: f5,
        globals: b5
      } = this.storyStoreValue.getStoryContext(d.story);
      this.channel.emit(w, {
        id: i,
        parameters: m3,
        initialArgs: g,
        argTypes: S4,
        args: h
      }), this.channel.emit(U, { userGlobals: R4, storyGlobals: f5, globals: b5, initialGlobals: E2 });
    } else {
      let { parameters: m3 } = this.storyStoreValue.projectAnnotations, { initialGlobals: g, globals: S4 } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(U, {
        globals: S4,
        initialGlobals: g,
        storyGlobals: {},
        userGlobals: S4
      }), ea(d) || ((_d = d.entry.tags) == null ? void 0 : _d.includes(Go))) {
        if (!d.csfFiles)
          throw new H({ storyId: i });
        ({ parameters: m3 } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: d.csfFiles[0]
        }));
      }
      this.channel.emit(D, {
        id: i,
        parameters: m3
      });
    }
    at(d) ? (or(!!d.story), this.storyRenders.push(d), this.currentRender.renderToElement(
      this.view.prepareForStory(d.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(t3, { viewModeChanged: o2 = false } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((n3) => n3 !== t3), await ((_a = t3 == null ? void 0 : t3.teardown) == null ? void 0 : _a.call(t3, { viewModeChanged: o2 }));
  }
  // UTILITIES
  mainStoryCallbacks(t3) {
    return {
      showStoryDuringRender: s3(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: s3(() => this.view.showMain(), "showMain"),
      showError: s3((o2) => this.renderError(t3, o2), "showError"),
      showException: s3((o2) => this.renderException(t3, o2), "showException")
    };
  }
  renderPreviewEntryError(t3, o2) {
    super.renderPreviewEntryError(t3, o2), this.view.showErrorDisplay(o2);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(V);
  }
  renderStoryLoadingException(t3, o2) {
    s.error(o2), this.view.showErrorDisplay(o2), this.channel.emit(V, t3);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(t3, o2) {
    let { name: n3 = "Error", message: i = String(o2), stack: a2 } = o2;
    this.channel.emit(K, { name: n3, message: i, stack: a2 }), this.channel.emit(B, { newPhase: "errored", storyId: t3 }), this.view.showErrorDisplay(
      o2
    ), s.error(`Error rendering story '${t3}':`), s.error(o2);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(t3, { title: o2, description: n3 }) {
    s.error(`Error rendering story ${o2}: ${n3}`), this.channel.emit(x, { title: o2, description: n3 }), this.channel.emit(B, { newPhase: "errored", storyId: t3 }), this.view.showErrorDisplay({
      message: o2,
      stack: n3
    });
  }
};
s3(lt, "PreviewWithSelection");
var we = lt;
var Be = he(cr(), 1);
var en = he(cr(), 1);
var Zo = /^[a-zA-Z0-9 _-]*$/;
var rn = /^-?[0-9]+(\.[0-9]+)?$/;
var Ca = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var tn = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var ht = s3((r3 = "", e2) => r3 === null || r3 === "" || !Zo.test(r3) ? false : e2 == null || e2 instanceof Date || typeof e2 == "number" || typeof e2 == "boolean" ? true : typeof e2 == "string" ? Zo.test(e2) || rn.test(e2) || Ca.test(e2) || tn.test(e2) : Array.isArray(e2) ? e2.every((t3) => ht(
  r3,
  t3
)) : L4(e2) ? Object.entries(e2).every(([t3, o2]) => ht(t3, o2)) : false, "validateArgs");
var Pa = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: true,
  arrayRepeat: true,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(r3) {
    if (r3.startsWith("!")) {
      if (r3 === "!undefined")
        return;
      if (r3 === "!null")
        return null;
      if (r3 === "!true")
        return true;
      if (r3 === "!false")
        return false;
      if (r3.startsWith("!date(") && r3.endsWith(")"))
        return new Date(r3.replaceAll(" ", "+").slice(6, -1));
      if (r3.startsWith("!hex(") && r3.endsWith(")"))
        return `#${r3.slice(5, -1)}`;
      let e2 = r3.slice(1).match(tn);
      if (e2)
        return r3.startsWith("!rgba") || r3.startsWith("!RGBA") ? `${e2[1]}(${e2[2]}, ${e2[3]}, ${e2[4]}, ${e2[5]})` : r3.startsWith("!hsla") || r3.startsWith(
          "!HSLA"
        ) ? `${e2[1]}(${e2[2]}, ${e2[3]}%, ${e2[4]}%, ${e2[5]})` : r3.startsWith("!rgb") || r3.startsWith("!RGB") ? `${e2[1]}(${e2[2]}, ${e2[3]}, ${e2[4]})` : `${e2[1]}(${e2[2]}, ${e2[3]}%, ${e2[4]}%)`;
    }
    return rn.test(r3) ? Number(r3) : r3;
  }
};
var mt = s3((r3) => {
  let e2 = r3.split(";").map((t3) => t3.replace("=", "~").replace(":", "="));
  return Object.entries((0, en.parse)(e2.join(";"), Pa)).reduce((t3, [o2, n3]) => ht(o2, n3) ? Object.assign(t3, { [o2]: n3 }) : (n.warn(P5`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url
    `), t3), {});
}, "parseArgsParam");
var { history: on, document: te2 } = I5;
function Fa(r3) {
  let e2 = (r3 || "").match(/^\/story\/(.+)/);
  if (!e2)
    throw new Error(`Invalid path '${r3}',  must start with '/story/'`);
  return e2[1];
}
s3(Fa, "pathToId");
var nn = s3(({
  selection: r3,
  extraParams: e2
}) => {
  let t3 = te2 == null ? void 0 : te2.location.search.slice(1), { path: o2, selectedKind: n3, selectedStory: i, ...a2 } = (0, Be.parse)(t3);
  return `?${(0, Be.stringify)({
    ...a2,
    ...e2,
    ...r3 && { id: r3.storyId, viewMode: r3.viewMode }
  })}`;
}, "getQueryString");
var Ia = s3((r3) => {
  if (!r3)
    return;
  let e2 = nn({ selection: r3 }), { hash: t3 = "" } = te2.location;
  te2.title = r3.storyId, on.replaceState({}, "", `${te2.location.pathname}${e2}${t3}`);
}, "setPath");
var Oa = s3((r3) => r3 != null && typeof r3 == "object" && Array.isArray(r3) === false, "isObject");
var Ge = s3(
  (r3) => {
    if (r3 !== void 0) {
      if (typeof r3 == "string")
        return r3;
      if (Array.isArray(r3))
        return Ge(r3[0]);
      if (Oa(r3))
        return Ge(
          Object.values(r3).filter(Boolean)
        );
    }
  },
  "getFirstString"
);
var Da = s3(() => {
  if (typeof te2 < "u") {
    let r3 = te2.location.search.slice(1), e2 = (0, Be.parse)(r3), t3 = typeof e2.args == "string" ? mt(e2.args) : void 0, o2 = typeof e2.globals == "string" ? mt(e2.globals) : void 0, n3 = Ge(e2.viewMode);
    (typeof n3 != "string" || !n3.match(/docs|story/)) && (n3 = "story");
    let i = Ge(e2.path), a2 = i ? Fa(i) : Ge(e2.id);
    if (a2)
      return { storySpecifier: a2, args: t3, globals: o2, viewMode: n3 };
  }
  return null;
}, "getSelectionSpecifierFromPath");
var gt = class gt2 {
  constructor() {
    this.selectionSpecifier = Da();
  }
  setSelection(e2) {
    this.selection = e2, Ia(this.selection);
  }
  setQueryParams(e2) {
    let t3 = nn({ extraParams: e2 }), { hash: o2 = "" } = te2.location;
    on.replaceState({}, "", `${te2.location.pathname}${t3}${o2}`);
  }
};
s3(gt, "UrlStore");
var ve = gt;
var Mn = he(jn(), 1);
var _n = he(cr(), 1);
var { document: j3 } = I5;
var Ln = 100;
var qn = ((i) => (i.MAIN = "MAIN", i.NOPREVIEW = "NOPREVIEW", i.PREPARING_STORY = "PREPARING_STORY", i.PREPARING_DOCS = "PREPARING_DOCS", i.ERROR = "ERROR", i))(qn || {});
var wt = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
};
var vt = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
};
var Nn = new Mn.default({
  escapeXML: true
});
var At = class At2 {
  constructor() {
    this.testing = false;
    if (typeof j3 < "u") {
      let { __SPECIAL_TEST_PARAMETER__: e2 } = (0, _n.parse)(j3.location.search.slice(1));
      switch (e2) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = true;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = true;
          break;
        }
        default:
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(e2) {
    return this.showStory(), this.applyLayout(e2.parameters.layout), j3.documentElement.scrollTop = 0, j3.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return j3.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), j3.documentElement.scrollTop = 0, j3.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return j3.getElementById("storybook-docs");
  }
  applyLayout(e2 = "padded") {
    if (e2 === "none") {
      j3.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(e2);
    let t3 = vt[e2];
    j3.body.classList.remove(this.currentLayoutClass), j3.body.classList.add(t3), this.currentLayoutClass = t3;
  }
  checkIfLayoutExists(e2) {
    vt[e2] || s.warn(
      P5`
          The desired layout: ${e2} is not a valid option.
          The possible options are: ${Object.keys(vt).join(", ")}, none.
        `
    );
  }
  showMode(e2) {
    clearTimeout(this.preparingTimeout), Object.keys(qn).forEach((t3) => {
      t3 === e2 ? j3.body.classList.add(wt[t3]) : j3.body.classList.remove(wt[t3]);
    });
  }
  showErrorDisplay({ message: e2 = "", stack: t3 = "" }) {
    let o2 = e2, n3 = t3, i = e2.split(`
`);
    i.length > 1 && ([o2] = i, n3 = i.slice(1).join(`
`).replace(/^\n/, "")), j3.getElementById("error-message").innerHTML = Nn.toHtml(o2), j3.getElementById("error-stack").innerHTML = Nn.toHtml(n3), this.showMode("ERROR");
  }
  showNoPreview() {
    var _a, _b;
    this.testing || (this.showMode("NOPREVIEW"), (_a = this.storyRoot()) == null ? void 0 : _a.setAttribute("hidden", "true"), (_b = this.docsRoot()) == null ? void 0 : _b.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate: e2 = false } = {}) {
    clearTimeout(this.preparingTimeout), e2 ? this.showMode("PREPARING_STORY") : this.preparingTimeout = setTimeout(
      () => this.showMode("PREPARING_STORY"),
      Ln
    );
  }
  showPreparingDocs({ immediate: e2 = false } = {}) {
    clearTimeout(this.preparingTimeout), e2 ? this.showMode("PREPARING_DOCS") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS"), Ln);
  }
  showMain() {
    this.showMode("MAIN");
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    j3.body.classList.add(wt.MAIN);
  }
};
s3(At, "WebView");
var Ae = At;
var Ct = class Ct2 extends we {
  constructor(t3, o2) {
    super(t3, o2, new ve(), new Ae());
    this.importFn = t3;
    this.getProjectAnnotations = o2;
    I5.__STORYBOOK_PREVIEW__ = this;
  }
};
s3(Ct, "PreviewWeb");
var { document: fe } = I5;
var yl = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
];
var hl = "script";
var Un = "scripts-root";
function Sr() {
  let r3 = fe.createEvent("Event");
  r3.initEvent("DOMContentLoaded", true, true), fe.dispatchEvent(r3);
}
s3(Sr, "simulateDOMContentLoaded");
function ml(r3, e2, t3) {
  let o2 = fe.createElement("script");
  o2.type = r3.type === "module" ? "module" : "text/javascript", r3.src ? (o2.onload = e2, o2.onerror = e2, o2.src = r3.src) : o2.textContent = r3.innerText, t3 ? t3.appendChild(o2) : fe.head.appendChild(o2), r3.parentNode.removeChild(r3), r3.src || e2();
}
s3(ml, "insertScript");
function Gn(r3, e2, t3 = 0) {
  r3[t3](() => {
    t3++, t3 === r3.length ? e2() : Gn(r3, e2, t3);
  });
}
s3(Gn, "insertScriptsSequentially");
function Bn(r3) {
  let e2 = fe.getElementById(Un);
  e2 ? e2.innerHTML = "" : (e2 = fe.createElement("div"), e2.id = Un, fe.body.appendChild(e2));
  let t3 = Array.from(r3.querySelectorAll(hl));
  if (t3.length) {
    let o2 = [];
    t3.forEach((n3) => {
      let i = n3.getAttribute("type");
      (!i || yl.includes(i)) && o2.push((a2) => ml(n3, a2, e2));
    }), o2.length && Gn(o2, Sr, void 0);
  } else
    Sr();
}
s3(Bn, "simulatePageLoad");

export {
  Z,
  ee,
  L3 as L,
  V4 as V,
  jt,
  Hr,
  M2 as M,
  Jr,
  $s,
  Js,
  Ro,
  Zs
};
//# sourceMappingURL=chunk-A2UQS4BV.js.map
